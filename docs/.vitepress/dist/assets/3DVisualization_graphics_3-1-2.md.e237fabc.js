import{_ as a,o as e,c as i,Q as t}from"./chunks/framework.5b0c684c.js";const s="/blogs/assets/3DVisualization_graphics_3_1-26.a7640545.png",o="/blogs/assets/3DVisualization_graphics_3_1-22.3ae36d0a.png",l="/blogs/assets/3DVisualization_graphics_3_1-23.a1faf400.png",r="/blogs/assets/3DVisualization_graphics_3_1-24.b8e9477f.png",c="/blogs/assets/3DVisualization_graphics_3_1-25.5bb64e31.png",k=JSON.parse('{"title":"光栅化的可见性/闭塞性","description":"","frontmatter":{},"headers":[],"relativePath":"3DVisualization/graphics/3-1-2.md","filePath":"3DVisualization/graphics/3-1-2.md","lastUpdated":1729031503000}'),n={name:"3DVisualization/graphics/3-1-2.md"},u=t('<h1 id="光栅化的可见性-闭塞性" tabindex="-1">光栅化的可见性/闭塞性 <a class="header-anchor" href="#光栅化的可见性-闭塞性" aria-label="Permalink to &quot;光栅化的可见性/闭塞性&quot;">​</a></h1><h2 id="可见性-闭塞性" tabindex="-1">可见性/闭塞性 <a class="header-anchor" href="#可见性-闭塞性" aria-label="Permalink to &quot;可见性/闭塞性&quot;">​</a></h2><ul><li>使用深度缓存/缓冲</li></ul><h2 id="画家的算法" tabindex="-1">画家的算法 <a class="header-anchor" href="#画家的算法" aria-label="Permalink to &quot;画家的算法&quot;">​</a></h2><p><img src="'+s+'" alt=""></p><ul><li>其灵感来自于画家的绘画方式。</li><li>先远后近，近的图形可以覆盖远图形的。（顺序很重要）</li><li>需要进行深度排序（n个三角形的O（nlogn））</li></ul><p><img src="'+o+'" alt=""></p><blockquote><p>而出现这种复杂的情况时（环），实际做法中种画家算法就无法适应了（无法定义他们的深度关系）。因此出现了 <code>Z-Buffer</code>算法</p></blockquote><h2 id="z-buffer-深度缓存-缓冲算法" tabindex="-1">Z-Buffer（深度缓存/缓冲算法） <a class="header-anchor" href="#z-buffer-深度缓存-缓冲算法" aria-label="Permalink to &quot;Z-Buffer（深度缓存/缓冲算法）&quot;">​</a></h2><ul><li>无法对三角形的深度关系定义，但可以对每<code>一个像素的顺序</code>进行排序。</li><li>用一个额外的缓冲区来存储深度值： <blockquote><p>frame buffer： 当前的场景信息（最后的结果）。</p><p>depth buffer： 当前场景每个像素的深度。</p></blockquote></li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>为简单起见，我们假设z（深度）总是正的：它就是物体到相机的距离，越小的距离表示越近，越大的距离表示越远。</p></div><p><img src="'+l+'" alt=""></p><h2 id="z-buffer-算法" tabindex="-1">Z-Buffer 算法 <a class="header-anchor" href="#z-buffer-算法" aria-label="Permalink to &quot;Z-Buffer 算法&quot;">​</a></h2><p>初始化深度缓冲器为∞，栅格化期间： <img src="'+r+'" alt=""></p><p>示例 <img src="'+c+'" alt=""></p><blockquote><p>惰性覆盖：当深度缓存相同时，不会覆盖，沿用已有的深度。</p></blockquote><h2 id="z-buffer-算法复杂度" tabindex="-1">Z-Buffer 算法复杂度 <a class="header-anchor" href="#z-buffer-算法复杂度" aria-label="Permalink to &quot;Z-Buffer 算法复杂度&quot;">​</a></h2><ul><li>n个三角形的O(n)（假设覆盖范围不变）</li><li>它有一个非常好的性质，它与顺序是没有关系的。</li></ul>',18),p=[u];function _(f,h,d,b,m,g){return e(),i("div",null,p)}const z=a(n,[["render",_]]);export{k as __pageData,z as default};
