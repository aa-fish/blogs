import{_ as t,o as l,c as o,Q as s}from"./chunks/framework.5b0c684c.js";const e="/blogs/assets/data-structure_3-10_1.4c0a38c4.png",c="/blogs/assets/data-structure_3-10_2.3f6a707f.png",a="/blogs/assets/data-structure_3-10_3.fd426671.png",i="/blogs/assets/data-structure_3-10_4.30017752.png",r="/blogs/assets/data-structure_3-10_5.6ab343ab.png",p="/blogs/assets/data-structure_3-10_8.e6a000c1.png",d="/blogs/assets/data-structure_3-10_9.9a642ec4.png",u="/blogs/assets/data-structure_3-10_10.33254772.png",b="/blogs/assets/data-structure_3-10_11.115fefac.png",n="/blogs/assets/data-structure_3-10_12.39a1b81f.png",h="/blogs/assets/data-structure_3-10_13.8fc6f96c.png",k="/blogs/assets/data-structure_3-10_15.487189dc.png",g="/blogs/assets/data-structure_3-10_16.49769d71.png",_="/blogs/assets/data-structure_3-10_17.199b9204.png",q="/blogs/assets/data-structure_3-10_18.12934dfc.png",m="/blogs/assets/data-structure_3-10_19.d8999b21.png",f="/blogs/assets/data-structure_3-10_20.9a913b24.png",v="/blogs/assets/data-structure_3-10_21.4ee33b96.png",V="/blogs/assets/data-structure_3-10_22.0c825055.png",x="/blogs/assets/data-structure_3-10_23.4b37002f.png",y="/blogs/assets/data-structure_3-10_24.40042000.png",G="/blogs/assets/data-structure_3-10_25.ef1fff54.png",L=JSON.parse('{"title":"什么是图","description":"","frontmatter":{},"headers":[],"relativePath":"data-structure/3-10.md","filePath":"data-structure/3-10.md","lastUpdated":1729031503000}'),S={name:"data-structure/3-10.md"},P=s('<h1 id="什么是图" tabindex="-1">什么是图 <a class="header-anchor" href="#什么是图" aria-label="Permalink to &quot;什么是图&quot;">​</a></h1><div class="info custom-block"><p class="custom-block-title">【示例】</p><p><code>六度空间理论</code>：你和任何一个不相识的陌生人之间相隔的人数不会超过六个。</p><p><code>村村通</code>： <img src="'+e+'" alt="图片"></p></div><div class="tip custom-block"><p class="custom-block-title">⭐⭐⭐ 重要 ⭐⭐⭐</p><p><span class="line1">线性表是<code>一对一</code>的关系，树是<code>一对多</code>的关系，而<strong>图则表示</strong><code>多对多</code>的关系。线性表、树 是图的特殊情况。</span></p></div><p><img src="'+c+'" alt="图片"></p><h2 id="抽象数据类型描述" tabindex="-1">抽象数据类型描述 <a class="header-anchor" href="#抽象数据类型描述" aria-label="Permalink to &quot;抽象数据类型描述&quot;">​</a></h2><ul><li>类型名称：图（Graph）；</li><li>数据对象集：G（V,E）由<code>一个非空的有限顶点集合 V </code>和<code>一个有限边集合 E </code>组成；</li><li>操作集：对于任意图 G ∈ Graph，以及 v ∈ V，e ∈ E； <blockquote><ol><li><p>Graph Create()：建立并返回空图；</p></li><li><p>Graph InsertVertex(Graph G, Vertex V)：将 V 差入 G（插入顶点）；</p></li><li><p>Graph InsertEdge(Graph G, Edge e)：将 e 插入 G （插入边）；</p></li><li><p>void DFS(Graph G, Vertex V)：从顶点v出发深度优先遍历图G；</p></li><li><p>void BFS(Graph G, Vertex V)：从顶点v出发广度优先遍历图G；</p></li><li><p>void ShortestPath(Graph G, Vertex V, int Dist[])：计算图 G 中顶点 v 到任意其他顶点的最短距离；</p></li><li><p>void MST(Graph G)：计算图 G 的最小生成树；</p></li></ol><p>......</p></blockquote></li></ul><h2 id="图的术语" tabindex="-1">图的术语 <a class="header-anchor" href="#图的术语" aria-label="Permalink to &quot;图的术语&quot;">​</a></h2><ol><li>有向图</li><li>无向图</li><li>网络</li><li>.......</li></ol><h2 id="邻接矩阵【数组表示图】" tabindex="-1">邻接矩阵【数组表示图】 <a class="header-anchor" href="#邻接矩阵【数组表示图】" aria-label="Permalink to &quot;邻接矩阵【数组表示图】&quot;">​</a></h2><p>左边的图 用 矩阵表示 <img src="'+a+'" alt="图片"></p><p><strong>存在的问题</strong>：对于无向图的存储，怎么样可以省一半的空间？</p><p><strong>解决方法</strong>：如图 <img src="'+i+'" alt="图片"></p><p><strong>邻接矩阵优点</strong>：</p><ol><li>直观、简单、好理解；</li><li>方便检查任意一对顶点间是否存在边；</li><li>方便找任一顶点的所有“邻接点”（有边直接相连的顶点）；</li><li>方便计算任一顶点“度”（从该点发出的边数为“出度”，指向该点的边数为“入度”）；</li></ol><blockquote><p>无向图：对应行（或列），非0元素的个数；</p><p>有向图：对应行非0元素的个数是“出度”，对应列非0元素的个数是“入度”；</p></blockquote><p><strong>邻接矩阵缺点</strong>：</p><ol><li>浪费空间：<span class="line1">对稠密图（完全图）还是很合算的</span> ，对于稀疏图（点多 边少）有大量无效元素；</li><li>浪费时间：统计稀疏图中一共有多少条边（需要扫描一遍系数图）；</li></ol><h2 id="邻阶接表【链表表示图】" tabindex="-1">邻阶接表【链表表示图】 <a class="header-anchor" href="#邻阶接表【链表表示图】" aria-label="Permalink to &quot;邻阶接表【链表表示图】&quot;">​</a></h2><p><img src="'+r+'" alt="图片"><strong>邻接表优点</strong>：</p><ol><li>便找任一顶点的所有“邻接点”；</li><li>节约稀疏图的空间；</li></ol><blockquote><p>需要N个头指针+2E个结点(每个结点至少2个域)</p></blockquote><ol start="3"><li>计算任一顶点的“度”（无向图）方便； <strong>邻接表缺点</strong>：</li><li>计算任一顶点的“度”（有向图）困难；</li></ol><blockquote><p>对有向图:只能计算“出度”;需要构造“逆邻接表”(存指向自己的边)来方便计算“入度”</p></blockquote><ol start="2"><li>不方便检查任意一对顶点间是否存在边；</li></ol><div class="info custom-block"><p class="custom-block-title">注意</p><p>除了邻接矩阵、邻接表，图的表示方式有很多种，如：</p><ol><li>邻接多重表</li><li>十字链表</li><li>边</li></ol><p>具体要看解决什么类型的问题。</p></div><h2 id="图的遍历" tabindex="-1">图的遍历 <a class="header-anchor" href="#图的遍历" aria-label="Permalink to &quot;图的遍历&quot;">​</a></h2><h3 id="dfs-深度优先" tabindex="-1">DFS(深度优先) <a class="header-anchor" href="#dfs-深度优先" aria-label="Permalink to &quot;DFS(深度优先)&quot;">​</a></h3><p><img src="'+p+'" alt="图片"></p><h3 id="bfs-广度优先" tabindex="-1">BFS(广度优先) <a class="header-anchor" href="#bfs-广度优先" aria-label="Permalink to &quot;BFS(广度优先)&quot;">​</a></h3><p><img src="'+d+'" alt="图片"></p><br><br><div class="tip custom-block"><p class="custom-block-title">为什么需要这两种遍历方式呢</p><p>通过下面示例对比了解（走迷宫）</p><p><img src="'+u+'" alt="图片"></p><p>DFS规则:顺时针寻找相邻连接点（当然也可以定其他规则）</p><div class="dfs-graph"></div><table><thead><tr><th>⑧</th><th>①</th><th>②</th></tr></thead><tbody><tr><td>⑦</td><td>🚩</td><td>③</td></tr><tr><td>⑥</td><td>⑤</td><td>④</td></tr></tbody></table><p><img src="'+b+'" alt="图片"></p><p>DFS规则: 首先入口进入队列，然后开始把相邻的格子加入队列，一圈一圈的开始遍历搜索。</p><div class="bfs-graph"></div><table><thead><tr><th>②</th><th>②</th><th>②</th><th>②</th><th>②</th></tr></thead><tbody><tr><td>②</td><td>①</td><td>①</td><td>①</td><td>②</td></tr><tr><td>②</td><td>①</td><td>🚩</td><td>①</td><td>②</td></tr><tr><td>②</td><td>①</td><td>①</td><td>①</td><td>②</td></tr><tr><td>②</td><td>②</td><td>②</td><td>②</td><td>②</td></tr></tbody></table><p><img src="'+n+'" alt="图片"></p></div><p>图遍历，是从一个结点出发，沿着边的方向，依次访问图中其它各结点，且每个结点仅被访问一次。</p><div class="tip custom-block"><p class="custom-block-title">图遍历的一些概念</p><ol><li><p><code>连通</code>：如果从V到W存在一条（无向）路径，则称V和W是连通的；</p></li><li><p><code>路径</code>：从顶点V到顶点W存在一系列顶点{V,V1,V2...,W}的集合，<span class="line1">其中任一对相邻的顶点间都有图中的边</span><sup class="sup-tag">相连接的</sup>，</p><ul><li>路径长度：是路径中的边数（如果有带权，则是所有边的权重和）；</li><li>如果V到W之间的所有顶点都不同，则称<code>简单路径</code>，如果有回路就是不是简单路径；</li></ul></li><li><p><code>回路</code>：从顶点V到顶点V的一条路径；</p></li><li><p><code>连通图</code>：图中任意两个顶点钧连通；</p></li><li><p><code>连通分量</code>：<strong>无向图</strong>的极大连通子图；</p><ul><li>极大顶点数：再加一个顶点就不连通了；</li><li>极大边数：包含子图中所有顶点相连的所有边；</li></ul><div class="info custom-block"><p class="custom-block-title">示例</p><svg width="100%" height="400"><circle cx="20" cy="100" r="16" style="stroke:#00bb8c;fill:#00bb8c;"></circle><circle cx="120" cy="40" r="16" style="stroke:#00bb8c;fill:#00bb8c;"></circle><circle cx="220" cy="100" r="16" style="stroke:#00bb8c;fill:#00bb8c;"></circle><circle cx="120" cy="160" r="16" style="stroke:#00bb8c;fill:#00bb8c;"></circle><circle cx="80" cy="100" r="16" style="stroke:#00bb8c;fill:#00bb8c;"></circle><circle cx="160" cy="100" r="16" style="stroke:#00bb8c;fill:#00bb8c;"></circle><text style="font-size:18px;"><tspan x="114" y="44">A</tspan><tspan x="214" y="104">B</tspan><tspan x="114" y="164">C</tspan><tspan x="14" y="104">D</tspan><tspan x="74" y="104">E</tspan><tspan x="154" y="104">F</tspan></text><path d="M 20 100 L 120 40 L220 100 L120 160 L20 100" fill="none" style="stroke:#00bb8c;"></path><path d="M 80 100 L 160 100" fill="none" style="stroke:#00bb8c;"></path></svg></div></li><li><p><code>强连通</code>：有向图中顶点v和w之间存在双向路径（V--&gt;W，或者W--&gt;V往返的路径不一定是同一条），则称v和W是强连通的；</p></li><li><p><code>强连通图</code>：有向图中任意两顶点均强连通；</p><ul><li>弱连通图：强连通图边的方向抹掉，就是弱连通图；</li></ul></li><li><p><code>强连通分量</code>：有向图的极大强连通子图；</p></li></ol></div><h2 id="图的算法事例" tabindex="-1">图的算法事例 <a class="header-anchor" href="#图的算法事例" aria-label="Permalink to &quot;图的算法事例&quot;">​</a></h2><ol><li>拯救007</li><li>六度空间</li><li>哈利波特咒语</li><li>...</li></ol><h2 id="最短路径" tabindex="-1">最短路径 <a class="header-anchor" href="#最短路径" aria-label="Permalink to &quot;最短路径&quot;">​</a></h2><p>生活中从A地点到B地点，花最短时间、花最少的钱 都是图论中的最短路径问题。</p><div class="tip custom-block"><p class="custom-block-title"><strong>最短路径的抽象</strong></p><p>在网络中，求两个不同顶点之间的所有路径中，<code>边的权值之和最小</code>的那条路径。</p><blockquote><ul><li>这个路径就是两点之间的<code>最短路径</code>（Shortest Path）；</li><li>第一个顶点为<code>源点</code>（Source）；</li><li>最后一个顶点为<code>终点</code>（Destination）；</li></ul></blockquote></div><div class="tip custom-block"><p class="custom-block-title"><strong>最短路径问题分类</strong></p><p><span class="line1">单源最短路径</span>：从固定的某个源点出发：求其到所有其他顶点的最短路径。</p><blockquote><p><code>无权图</code>（有向/无向）：按照<code>递增（非递减）</code>的顺序找出各个顶点的最短路径；</p></blockquote><blockquote><p><img src="'+h+'" alt="图片"></p></blockquote><blockquote><p><img src="'+k+'" alt="图片"></p></blockquote><blockquote><p><code>有权图</code>（有向/无向）：按照<code>递增（非递减）</code><sup class="sup-tag">避免负线圈</sup> 的顺序找出各个顶点的最短路径；<code>Dijkstra算法</code>用于解决这一问题。</p></blockquote><blockquote><div class="info custom-block"><p class="custom-block-title">Dijkstra算法</p><ul><li>令S = { 源点s + 已经确定了最短路径的顶点V<sub>i</sub> }</li><li>对于任一未收录的顶点v，定义dist[v]为 s 到 v 的最短路径长度，但该路径仅经过S中的顶点，<br>即路径 {s →（ v<sub>i</sub> ∈ S） → v }的最小长度<sup class="sup-tag">（ v<sub>i</sub> ∈ S）是S中的最小路径</sup></li><li>路径按照<code>递增（非递减）</code>的顺序生成</li></ul><blockquote><ol><li>则正真最短路径必须只经过S中的顶点；</li><li>每次从未收录的顶点中选一个dist最小的收录（采用<code>贪心算法</code>策略）；</li><li>增加一个v进入S，可能影响另外一个 w 的dist值；dist[w] = min { dist[w] ， dist[v] + &lt; v ， w &gt;的权重}</li></ol></blockquote></div></blockquote><blockquote><p><strong>Dijkstra算法收录方式</strong>：<br> 方法一： 直接扫描所有未收录的顶点 O（|V|），---- 稠密图优势</p><blockquote><p>T=O（|v|<sup>2</sup> + |E|）</p></blockquote></blockquote><blockquote><p>方法二： 将dist存在最小堆中 O（log|V|）， ---- 稀疏图优势</p><blockquote><p>更新dist[w]的值 O（log|V|）</p></blockquote></blockquote><blockquote><blockquote><p>T=O（|v|log|V| + |E|log|V|）= O（|E|log|V|）</p></blockquote></blockquote><blockquote><p><strong>Dijkstra算法实现</strong>： <img src="'+g+'" alt="图片"></p></blockquote><br><p><span class="line1">多源最短路径</span>：</p><p>方法一：直接将单元最短路径算法调用|V|遍</p><blockquote><p>T=O（|v|<sup>3</sup> + |E|*|V|），对于稀疏图比较合算；</p></blockquote><p>方法二：Floyd算法</p><blockquote><p>T=O（|v|<sup>3</sup>），对于稠密图合算；</p></blockquote><div class="info custom-block"><p class="custom-block-title">Floyd算法</p><p>Floyd 算法是一种<code>动态规划算法</code>，基于矩阵运算实现。其思想是通过中间节点逐步优化两个节点之间的距离。首先初始化一个邻接矩阵，其中每一个元素表示两个节点之间的距离，若节点之问没有边，则距离为无穷大。</p><ul><li>不是很理解，待补充...</li></ul></div></div><h2 id="最小生成树" tabindex="-1">最小生成树 <a class="header-anchor" href="#最小生成树" aria-label="Permalink to &quot;最小生成树&quot;">​</a></h2><p><strong>是一颗树</strong>：</p><blockquote><ul><li>无回路；</li><li>|V|个顶点一定有|V|-1条边；</li></ul></blockquote><p><strong>是生成树</strong>：</p><blockquote><ul><li>包含全部顶点；</li><li>|V|-1条边都在图里；</li><li>向生成树中任加一条边，都一定构成回路； <img src="'+_+'" alt="图片"></li></ul></blockquote><p><strong>边的权重和最小</strong></p><div class="danger custom-block"><p class="custom-block-title">贪心算法</p><ul><li><p>什么是“贪”：每一步都要最好；</p></li><li><p>什么是“好”：权重最小的边；</p></li><li><p>需要约束：</p><blockquote><p>只能用图里有的边</p></blockquote><blockquote><p>只能正好用掉|V|-1条边</p></blockquote><blockquote><p>不能有回路</p></blockquote></li></ul></div><br><h2 id="prim算法-生成最小生成树" tabindex="-1">Prim算法（生成最小生成树） <a class="header-anchor" href="#prim算法-生成最小生成树" aria-label="Permalink to &quot;Prim算法（生成最小生成树）&quot;">​</a></h2><blockquote><p><img src="'+q+'" alt="图片"></p></blockquote><blockquote><p><img src="'+m+'" alt="图片"></p></blockquote><h2 id="kruskal算法-将森林合并成树" tabindex="-1">Kruskal算法 （将森林合并成树） <a class="header-anchor" href="#kruskal算法-将森林合并成树" aria-label="Permalink to &quot;Kruskal算法 （将森林合并成树）&quot;">​</a></h2><blockquote><p><img src="'+f+'" alt="图片"></p></blockquote><blockquote><p><img src="'+v+'" alt="图片"></p></blockquote><h2 id="拓扑排序" tabindex="-1">拓扑排序 <a class="header-anchor" href="#拓扑排序" aria-label="Permalink to &quot;拓扑排序&quot;">​</a></h2><ul><li><p><strong>拓扑序</strong>：如果图中从V到W有一条有向路径，则V一定排在W之前。满足次条件的顶点序列称为一个<code>拓扑序</code>；</p></li><li><p>获得一个<code>拓扑序</code>的过程就是<code>拓扑排序</code>；</p></li><li><p>AOV如果有合理的拓扑序，则必定是<code>有向无环图</code>（Directed Acyclic Graph,DAG）；</p></li></ul><blockquote><p><img src="'+V+'" alt="图片"></p></blockquote><blockquote><p><img src="'+x+'" alt="图片"></p></blockquote><h2 id="关键路径" tabindex="-1">关键路径 <a class="header-anchor" href="#关键路径" aria-label="Permalink to &quot;关键路径&quot;">​</a></h2><blockquote><p><img src="'+y+'" alt="图片"></p></blockquote><blockquote><p><img src="'+G+'" alt="图片"></p></blockquote>',62),D=[P];function E(F,T,O,W,A,w){return l(),o("div",null,D)}const j=t(S,[["render",E]]);export{L as __pageData,j as default};
