import{_ as o,C as e,o as t,c,k as s,a as n,H as p,Q as a}from"./chunks/framework.5b0c684c.js";const _=JSON.parse('{"title":"Class","description":"","frontmatter":{},"headers":[],"relativePath":"web-core/es6/1-18.md","filePath":"web-core/es6/1-18.md","lastUpdated":1729031503000}'),r={name:"web-core/es6/1-18.md"},E=a("",39),y=s("li",null,"extends 关键字用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。",-1),i=s("li",null,"任何可以用 new 调用并具有 prototype 属性的构造函数都可以作为候选的父类的构造函数。这两个条件必须同时成立。ParentClass 的 prototype 属性必须是 Object 或 null。",-1),F=s("li",null,"extends 表达式中的 this 值是围绕类定义的 this ，而引用类的名称会导致 ReferenceError，因为类尚未初始化。在此表达式中，await 和 yield 按预期工作（因为此时没有初始化）。",-1),d=s("li",null,"基类可以从构造函数中返回任何内容，而派生类必须返回对象或 undefined ，否则将抛出 TypeError。（派生类中使用super()）",-1),u=s("li",null,"如果父类构造函数返回一个对象，则在进一步初始化类字段时，该对象将被用作派生类的 this 值。这种技巧被称为“返回覆盖”，它允许在无关对象上定义派生类的字段（包括私有字段）。",-1),C=a("",4),h={class:"danger custom-block"},A=s("p",{class:"custom-block-title"},"警告：",-1),g=a("",6),D={class:"details custom-block"},B=a("",4),v=a("",2),b=a("",5);function m(k,q,x,w,S,M){const l=e("lines");return t(),c("div",null,[E,s("ul",null,[y,i,s("li",null,[n("extend 的右侧不一定是标识符。你可以使用任何求值为构造函数的表达式。"),p(l,{text:"这通常有助于创建混入（mixin）"})]),F,d,u]),C,s("div",h,[A,s("p",null,[n("标准委员会目前的立场是，以前版本规范中的内置类的子类化机制设计过度，对性能和安全性造成了不可忽视的影响。新的内置方法较少考虑子类，引擎实现者正在研究是否要删除某些子类机制。"),p(l,{text:"在增强内置类时，请考虑使用组合而非继承"}),n("。")])]),g,s("details",D,[B,s("p",null,[n("继承常常会导致圆——椭圆问题，因为两种类型虽然有很多共同特征，但都不能完美地包含另一种类型的行为。"),p(l,{text:"一般来说，除非有非常充分的理由使用继承，否则最好使用组合"}),n("。组合是指一个类拥有另一个类对象的引用，但只将该对象用作实现细节。")]),v]),b])}const j=o(r,[["render",m]]);export{_ as __pageData,j as default};
