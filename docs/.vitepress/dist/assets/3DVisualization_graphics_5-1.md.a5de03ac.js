import{_ as s,o as a,c as o,Q as i}from"./chunks/framework.5b0c684c.js";const t="/blogs/assets/3DVisualization_graphics_5_1.4f21e0d1.png",p="/blogs/assets/3DVisualization_graphics_5_2.35b039b1.png",l="/blogs/assets/3DVisualization_graphics_5_3.f9ad260a.png",e="/blogs/assets/3DVisualization_graphics_5_4.586c1e6f.png",c="/blogs/assets/3DVisualization_graphics_5_5.f8cb8e48.png",r="/blogs/assets/3DVisualization_graphics_5_6.74735a10.png",_="/blogs/assets/3DVisualization_graphics_5_7.233cf747.png",n="/blogs/assets/3DVisualization_graphics_5_8.8847e442.png",u="/blogs/assets/3DVisualization_graphics_5_9.38402a72.png",g="/blogs/assets/3DVisualization_graphics_5_10.d82460b6.png",b="/blogs/assets/3DVisualization_graphics_5_11.9c22e804.png",h="/blogs/assets/3DVisualization_graphics_5_12.fa0a882a.png",m="/blogs/assets/3DVisualization_graphics_5_13.8e8493be.png",d="/blogs/assets/3DVisualization_graphics_5_14.21764891.png",q="/blogs/assets/3DVisualization_graphics_5_15.a204bf50.png",k="/blogs/assets/3DVisualization_graphics_5_16.812508a6.png",y=JSON.parse('{"title":"几何","description":"","frontmatter":{},"headers":[],"relativePath":"3DVisualization/graphics/5-1.md","filePath":"3DVisualization/graphics/5-1.md","lastUpdated":1729031503000}'),f={name:"3DVisualization/graphics/5-1.md"},z=i('<h1 id="几何" tabindex="-1">几何 <a class="header-anchor" href="#几何" aria-label="Permalink to &quot;几何&quot;">​</a></h1><p><img src="'+t+'" alt=""></p><p><strong>什么是隐式几何</strong>：</p><ul><li>代数曲面</li><li>水平集</li><li>距离函数</li></ul><p><strong>什么是显示几何</strong>：</p><ul><li>点云</li><li>多边形网格</li><li>...</li></ul><h2 id="隐式几何" tabindex="-1">隐式几何 <a class="header-anchor" href="#隐式几何" aria-label="Permalink to &quot;隐式几何&quot;">​</a></h2><p>点满足某些特定的关系</p><p>三维图形中的所有点，其中x<sup>2</sup>+y<sup>2</sup>+z<sup>2</sup> = 1，满足 f(x，y，z)= 0</p><p><img src="'+p+'" alt=""></p><blockquote><p>红色表示1</p><p>蓝色表示-1</p><p>f=0，我们如果找到所有的f=0的点，它就可以形成一个几何图形，这就是隐式的几何。</p></blockquote><p><strong>隐式几何的表达方式</strong></p><p>坏处： <img src="'+l+'" alt=""></p><blockquote><p>在f（x，y，z）= 0 时，它是什么？其实它是一个圆环。</p><p>隐式的几何，它是<code>不直观、很难直接描述几何图形</code>。</p></blockquote><p>好处： <img src="'+e+'" alt=""></p><blockquote><p>(3/4, 1/2, 1/4) 这点在不在几何内？</p><p>隐式几何可以<code>很容易判断出他们的几何关系</code>。</p></blockquote><p><strong>显示几何表示方式方法</strong></p><ul><li>一种是直接用几何图形表示。</li><li>还有一种是通过使用<code>函数参数映射</code>方式。</li></ul><blockquote><p>只要把每一个点找一边就能获得几何图形。</p></blockquote><p><img src="'+c+'" alt=""></p><p><img src="'+r+'" alt=""></p><blockquote><p>通过u v 参数映射</p></blockquote><p><img src="'+_+'" alt=""></p><blockquote><p>通过u v 参数映射，几何关系没那么容易判断。</p></blockquote><p>没有哪种表示是绝对的好和坏。根据具体情况使用合适的方式。</p><h2 id="csg表示几何-几何隐式表示" tabindex="-1">CSG表示几何（几何隐式表示） <a class="header-anchor" href="#csg表示几何-几何隐式表示" aria-label="Permalink to &quot;CSG表示几何（几何隐式表示）&quot;">​</a></h2><p>通过布尔运算组合隐式几何图形。（有非常广泛的应用）</p><ul><li>通过基本几何的基本运算，来定义新的几何。</li></ul><p><img src="'+n+'" alt=""></p><h2 id="距离函数表示几何-隐式" tabindex="-1">距离函数表示几何（隐式） <a class="header-anchor" href="#距离函数表示几何-隐式" aria-label="Permalink to &quot;距离函数表示几何（隐式）&quot;">​</a></h2><p><img src="'+u+'" alt=""></p><blockquote><p>距离函数：给出从任何地方到对象的最小距离（可以是有符号(正负)的距离）</p></blockquote><p>例如：混合（线性交错线）一个可移动的边界 <img src="'+g+'" alt=""></p><blockquote><p>S 表示正负</p><p>DF 表示距离函数</p><p>可以记录几何边界。</p></blockquote><p><img src="'+b+'" alt=""></p><p>纯距离函数表示的场景 <img src="'+h+'" alt=""></p><h2 id="水平集表示几何-隐式" tabindex="-1">水平集表示几何（隐式） <a class="header-anchor" href="#水平集表示几何-隐式" aria-label="Permalink to &quot;水平集表示几何（隐式）&quot;">​</a></h2><p>水平集和距离函数其实是一样的，只是表现行式不一样。 <img src="'+m+'" alt=""></p><blockquote><p>距离函数等于0的位置，它表示的就是物体的表面。</p><p>表面的插值等于零提供了更明确的控制形状（如纹理）</p><p>水平集在地理的<code>等高线</code>上有广泛应用。</p></blockquote><p>水平集也可以是定义在三维上的格子，这就与前面的纹理联系上了。</p><p><img src="'+d+'" alt=""></p><blockquote><p>假设我们有一个三维的纹理，表示的是人体各个部位的密度。</p><p>如何从这个三维的信息提取出物体的表面呢？</p><p>我们可以密度函数等于某个值，然后找到所有满足这个值的位置，这样我们就可以获得这个表面，然后也可以和纹理结合在一起。</p></blockquote><p>水滴效果 <img src="'+q+'" alt=""></p><blockquote><p>也可以通过距离函数(水平集)获得水滴与水面融合后的表面。</p></blockquote><h2 id="分形表示几何-隐式" tabindex="-1">分形表示几何（隐式） <a class="header-anchor" href="#分形表示几何-隐式" aria-label="Permalink to &quot;分形表示几何（隐式）&quot;">​</a></h2><p>自相似的意思（类似于计算中递归） <img src="'+k+'" alt=""></p><blockquote><p>分形在计算图形学中，在渲染的时候会引起强烈的走样，这在渲染中是一个非常大的挑战。</p></blockquote><h2 id="隐式表示的利与弊" tabindex="-1">隐式表示的利与弊 <a class="header-anchor" href="#隐式表示的利与弊" aria-label="Permalink to &quot;隐式表示的利与弊&quot;">​</a></h2><p>优点：</p><ul><li>隐式函数通常表述起来都很容易(一个公式就可以描述一个形状，这对于存储是非常有利的)。</li><li>某些查询很容易（内部对象，到曲面的距离），便于处理几个关系。</li><li>适合射线与表面相交（光线于物体表面）</li><li>对于简单的形状，精确的描述/无采样误差。</li><li>易于处理拓扑结构中的变化（例如，流体）。</li></ul><p>缺点:</p><ul><li>很难模拟复杂的形状。</li></ul>',52),D=[z];function V(x,P,S,T,v,C){return a(),o("div",null,D)}const A=s(f,[["render",V]]);export{y as __pageData,A as default};
