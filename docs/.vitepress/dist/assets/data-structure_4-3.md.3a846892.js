import{_ as t,o as e,c as a,Q as o}from"./chunks/framework.5b0c684c.js";const l="/blogs/assets/data-structure_4-3_1.f59bd325.png",b=JSON.parse('{"title":"插入排序","description":"","frontmatter":{},"headers":[],"relativePath":"data-structure/4-3.md","filePath":"data-structure/4-3.md","lastUpdated":1729031503000}'),s={name:"data-structure/4-3.md"},i=o('<h1 id="插入排序" tabindex="-1">插入排序 <a class="header-anchor" href="#插入排序" aria-label="Permalink to &quot;插入排序&quot;">​</a></h1><ul><li>就是跟打扑克一样的，摸到一张牌就插入一张牌（插入时的顺序看与小的比还是与大的比）；</li></ul><p><img src="'+l+'" alt="图片"></p><p>都有需要<code>交换9次</code>,这是巧合吗？</p><br><h2 id="时间复杂度下届" tabindex="-1">时间复杂度下届 <a class="header-anchor" href="#时间复杂度下届" aria-label="Permalink to &quot;时间复杂度下届&quot;">​</a></h2><p><strong>逆序对：对于下标i &lt; j，如果A[i] &gt; A[j]，则称(i,j)是一对逆序对(inversion)</strong></p><div class="tip custom-block"><p class="custom-block-title">问题-序列{34,8,64,51,32,21}中有多少逆序对?</p><p>(34,8)(34,32)(34,21)(64,51)(64,32)(64,21)(51,32)(51,21)(32,21) <code>9个逆序对</code>；</p><ul><li>交换2个相邻元素每次正好消去1个逆序对；</li><li>插入排序:T(N,I)=O(N+I)；</li><li>如果序列基本有序，则<code>插入排序简单且高效</code>；</li></ul></div><ul><li>定理1：任意N个不同元素组成的序列平均具有N(N-1)/4个逆序对；</li><li>定理2：任何仅以交换相邻两元素来排序的算法，其平均时间复杂度为Ω(N<sup>2</sup>)；</li><li>这意味着：要提高算法效率，我们必须 <blockquote><p>每次消去不止1个逆序对；</p><p>每次交换相隔较远的2个元素；</p></blockquote></li></ul>',9),c=[i];function r(d,_,p,n,u,h){return e(),a("div",null,c)}const f=t(s,[["render",r]]);export{b as __pageData,f as default};
