import{_ as t,o as s,c as a,Q as o}from"./chunks/framework.5b0c684c.js";const e="/blogs/assets/data-structure_3-7_1.67015f67.png",r="/blogs/assets/data-structure_3-7_2.700b05e3.png",l="/blogs/assets/data-structure_3-7_3.bcc03389.png",c="/blogs/assets/data-structure_3-7_4.e97a9307.png",i="/blogs/assets/data-structure_3-7_5.c8d6db9c.png",p="/blogs/assets/data-structure_3-7_6.f83d679b.png",n="/blogs/assets/data-structure_3-7_7.d73ad4ee.png",d="/blogs/assets/data-structure_3-7_8.26300d39.png",_="/blogs/assets/data-structure_3-7_9.d7357afd.png",N=JSON.parse('{"title":"什么是堆","description":"","frontmatter":{},"headers":[],"relativePath":"data-structure/3-7.md","filePath":"data-structure/3-7.md","lastUpdated":1729031503000}'),u={name:"data-structure/3-7.md"},m=o('<h1 id="什么是堆" tabindex="-1">什么是堆 <a class="header-anchor" href="#什么是堆" aria-label="Permalink to &quot;什么是堆&quot;">​</a></h1><p><code>优先队列</code>（Priority Queue）：它是一种“特殊的队列”，取出元素的顺序是依照元素的<code>优先权（关键字）</code>大小，而不是元素进入的队列的先后顺序。</p><h2 id="堆的实现" tabindex="-1">堆的实现 <a class="header-anchor" href="#堆的实现" aria-label="Permalink to &quot;堆的实现&quot;">​</a></h2><p><img src="'+e+'" alt="图片"></p><p>使用<strong>数组</strong>、<strong>链表</strong>表示【堆】的时候，在<strong>查找</strong>、<strong>插入</strong>或者<strong>删除</strong>的时候，总有一些操作复杂度不够小。有没有更好的办法呢？--&gt; <code>二叉搜索树</code></p><p><strong>二叉搜索树</strong>表示【堆】：<strong>查找</strong>、<strong>插入</strong>、<strong>删除</strong>操作复杂度与树的高度相关（O(logn)），问题在于，如果每次都删除、或者插入最大的值，几次操作后，会导致二叉搜索树失去平衡，复杂度就上升了。</p><h2 id="完全二叉树表示【堆】" tabindex="-1">完全二叉树表示【堆】 <a class="header-anchor" href="#完全二叉树表示【堆】" aria-label="Permalink to &quot;完全二叉树表示【堆】&quot;">​</a></h2><p><strong>完全二叉树</strong>表示【堆】：满足，每个结点的元素值不小（或不大于）于其子结点的元素值。</p><h2 id="堆的特性" tabindex="-1">堆的特性 <a class="header-anchor" href="#堆的特性" aria-label="Permalink to &quot;堆的特性&quot;">​</a></h2><p><img src="'+r+'" alt="图片"><img src="'+l+'" alt="图片"></p><h2 id="堆的抽象数据类型描述" tabindex="-1">堆的抽象数据类型描述 <a class="header-anchor" href="#堆的抽象数据类型描述" aria-label="Permalink to &quot;堆的抽象数据类型描述&quot;">​</a></h2><div class="info custom-block"><p class="custom-block-title">抽象数据类型描述</p><p>类型名称：最大堆（MaxHeap）</p><p>数据对象集：完全二叉树，每个结点的元素值不小于其子结点的元素值。</p><p>操作集：最大堆H∈MaxHeap，元素item∈ElementType，主要操作有：</p><blockquote><ol><li><p>创建一个空的最大堆。</p></li><li><p>判断最大堆H是否已经满。</p></li><li><p>将元素item插入最大堆H。</p></li><li><p>判断最大推H是否为空。</p></li><li><p>返回H中最大元素（高优先级）。</p></li></ol></blockquote></div><h2 id="最大堆的操作" tabindex="-1">最大堆的操作 <a class="header-anchor" href="#最大堆的操作" aria-label="Permalink to &quot;最大堆的操作&quot;">​</a></h2><details class="details custom-block"><summary>初始化</summary><p><img src="'+c+'" alt="图片"></p></details><details class="details custom-block"><summary>插入</summary><p><img src="'+i+'" alt="图片"><img src="'+p+'" alt="图片"></p></details><details class="details custom-block"><summary>删除</summary><p><img src="'+n+'" alt="图片"><img src="'+d+'" alt="图片"></p></details><details class="details custom-block"><summary>应用创建</summary><p><strong>如何使用堆排序？</strong> 建立最大堆：将已经存在的N个元素按照最大堆要求存放在一个一维数组中。</p><p>方法1：通过插入操作，将N个元素一个个相续插入到一个初始为空的堆中，其中时间代价最大为O(NlogN)</p><p>方法2：在线性时间复杂度下建立最大堆，</p><blockquote><p>（1）将N个元素按照顺序存入，先满足完全二叉树的结构特性。</p><p>（2）再调整各结点位置，以满足最大堆的有序特性。</p><blockquote><p>怎么调整？从倒数第一个开始，从下往上调整 <img src="'+_+'" alt="图片"></p></blockquote></blockquote></details>',17),g=[m];function b(h,k,f,q,x,P){return s(),a("div",null,g)}const H=t(u,[["render",b]]);export{N as __pageData,H as default};
