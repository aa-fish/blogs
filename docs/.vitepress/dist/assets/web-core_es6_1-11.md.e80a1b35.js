import{_ as e,o as a,c as t,Q as l}from"./chunks/framework.5b0c684c.js";const k=JSON.parse('{"title":"Set  Map","description":"","frontmatter":{},"headers":[],"relativePath":"web-core/es6/1-11.md","filePath":"web-core/es6/1-11.md","lastUpdated":1729031503000}'),o={name:"web-core/es6/1-11.md"},r=l('<h1 id="set-map" tabindex="-1">Set Map <a class="header-anchor" href="#set-map" aria-label="Permalink to &quot;Set  Map&quot;">​</a></h1><h2 id="set" tabindex="-1">Set <a class="header-anchor" href="#set" aria-label="Permalink to &quot;Set&quot;">​</a></h2><ul><li>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</li><li>Set本身是一个构造函数，用来生成 Set 数据结构。</li><li>向 Set 加入值的时候，不会发生类型转换。</li><li>Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（===），主要的区别是向 Set 加入值时认为NaN等于自身，而精确相等运算符认为NaN不等于自身。</li></ul><h2 id="set-实例属性" tabindex="-1">Set 实例属性 <a class="header-anchor" href="#set-实例属性" aria-label="Permalink to &quot;Set 实例属性&quot;">​</a></h2><h2 id="set-prototype-constructor" tabindex="-1">Set.prototype.constructor <a class="header-anchor" href="#set-prototype-constructor" aria-label="Permalink to &quot;Set.prototype.constructor&quot;">​</a></h2><ul><li><strong>描述</strong>：构造函数，默认就是Set函数。</li></ul><h2 id="set-prototype-size" tabindex="-1">Set.prototype.size <a class="header-anchor" href="#set-prototype-size" aria-label="Permalink to &quot;Set.prototype.size&quot;">​</a></h2><ul><li><strong>描述</strong>：返回Set实例的成员总数。</li></ul><h2 id="set-实例方法" tabindex="-1">Set 实例方法 <a class="header-anchor" href="#set-实例方法" aria-label="Permalink to &quot;Set 实例方法&quot;">​</a></h2><p><strong>用于操作数据</strong></p><ul><li>Set.prototype.add(value)：添加某个值，返回 Set 结构本身。</li><li>Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</li><li>Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。</li><li>Set.prototype.clear()：清除所有成员，没有返回值。</li></ul><p><strong>用于遍历成员</strong></p><ul><li>Set.prototype.keys()：返回键名的遍历器</li><li>Set.prototype.values()：返回键值的遍历器</li><li>Set.prototype.entries()：返回键值对的遍历器</li><li>Set.prototype.forEach()：使用回调函数遍历每个成员</li></ul><h2 id="weakset" tabindex="-1">WeakSet <a class="header-anchor" href="#weakset" aria-label="Permalink to &quot;WeakSet&quot;">​</a></h2><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p><ul><li>WeakSet 的成员只能是对象，而不能是其他类型的值。</li><li>WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</li></ul><h2 id="map" tabindex="-1">Map <a class="header-anchor" href="#map" aria-label="Permalink to &quot;Map&quot;">​</a></h2><ul><li>ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</li><li>Map 数据结构是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</li><li>任何具有 Iterator 接口、都可以当作Map构造函数的参数。这就是说，Set和Map都可以用来生成新的 Map。</li><li>注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。</li></ul><h2 id="map实例属性" tabindex="-1">map实例属性 <a class="header-anchor" href="#map实例属性" aria-label="Permalink to &quot;map实例属性&quot;">​</a></h2><p>Map.prototype.size</p><ul><li><strong>描述</strong>：返回 Map 结构的成员总数。</li></ul><h2 id="map实例方法" tabindex="-1">map实例方法 <a class="header-anchor" href="#map实例方法" aria-label="Permalink to &quot;map实例方法&quot;">​</a></h2><p><strong>用于操作数据</strong></p><ul><li>Map.prototype.set(key, value)</li><li>Map.prototype.get(key)</li><li>Map.prototype.has(key)</li><li>Map.prototype.delete(key)</li><li>Map.prototype.clear()</li></ul><p><strong>用于遍历数据</strong></p><ul><li>Map.prototype.keys()：返回键名的遍历器。</li><li>Map.prototype.values()：返回键值的遍历器。</li><li>Map.prototype.entries()：返回所有成员的遍历器。</li><li>Map.prototype.forEach()：遍历 Map 的所有成员。</li></ul><h2 id="weakmap" tabindex="-1">WeakMap <a class="header-anchor" href="#weakmap" aria-label="Permalink to &quot;WeakMap&quot;">​</a></h2><p>WeakMap结构与Map结构类似，也是用于生成键值对的集合。WeakMap与Map的区别有两点。</p><ul><li>WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。</li><li>WeakMap的键名所指向的对象，不计入垃圾回收机制。</li></ul>',29),i=[r];function p(s,n,h,u,c,d){return a(),t("div",null,i)}const m=e(o,[["render",p]]);export{k as __pageData,m as default};
