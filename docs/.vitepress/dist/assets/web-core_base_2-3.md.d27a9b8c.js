import{_ as o,o as t,c as r,Q as e}from"./chunks/framework.5b0c684c.js";const a="/blogs/assets/web-core_base_2_3-1.b7ee0dfa.png",g=JSON.parse('{"title":"原型与原型链","description":"","frontmatter":{},"headers":[],"relativePath":"web-core/base/2-3.md","filePath":"web-core/base/2-3.md","lastUpdated":1729031503000}'),c={name:"web-core/base/2-3.md"},s=e('<h1 id="原型与原型链" tabindex="-1">原型与原型链 <a class="header-anchor" href="#原型与原型链" aria-label="Permalink to &quot;原型与原型链&quot;">​</a></h1><p>在 JavaScript 中，<code>原型</code>和<code>原型链</code>是实现<code>继承</code>和<code>共享</code>属性的基础。</p><p><img src="'+a+'" alt="图片"></p><h2 id="原型" tabindex="-1">原型 <a class="header-anchor" href="#原型" aria-label="Permalink to &quot;原型&quot;">​</a></h2><p>每个 JavaScript 对象（除了 null）都有一个关联的对象，称为原型。每个对象从原型继承属性和方法。可以通过<code>__proto__</code> 属性访问对象的原型（不推荐直接使用），或者通过 Object.getPrototypeOf 方法来获取。</p><h2 id="原型链" tabindex="-1">原型链 <a class="header-anchor" href="#原型链" aria-label="Permalink to &quot;原型链&quot;">​</a></h2><p>当试图访问一个对象的属性时，JavaScript 引擎首先会在对象自身的属性中查找。如果找不到，它会继续在对象关联的的原型中查找，这个过程会一直持续下去，直到找到该属性或到达原型链的末尾（null）。这种一层一层的关联关系形成的链我们称之为<code>原型链</code>。</p><h2 id="constructor" tabindex="-1">constructor <a class="header-anchor" href="#constructor" aria-label="Permalink to &quot;constructor&quot;">​</a></h2><p>在 JavaScript 中，constructor 属性指向创建实例对象的构造函数。每个对象都有一个 constructor 属性，这个属性实际上是被当做共享属性放在它们的原型对象中。</p><ul><li>对象的 <code>constructor</code> 属性：指向创建该对象的构造函数。</li><li>原型对象的 <code>constructor</code> 属性：指向关联的构造函数。</li></ul><h2 id="prototype" tabindex="-1">prototype <a class="header-anchor" href="#prototype" aria-label="Permalink to &quot;prototype&quot;">​</a></h2><p>prototype 属性只存在于函数对象上。在 JavaScript 中，每个函数（包括构造函数）都有一个 prototype 属性。</p><h2 id="proto" tabindex="-1">proto <a class="header-anchor" href="#proto" aria-label="Permalink to &quot;proto&quot;">​</a></h2><p>在 JavaScript 中，<strong>proto</strong> 属性是每个对象（除了 null）都有的一个内部属性，用于指向该对象的原型。所有的实例对象都有<code>__proto__</code>属性。</p><ul><li><strong>访问原型</strong>：<strong>proto</strong> 属性允许你访问和设置对象的原型，但直接使用 <strong>proto</strong> 并不推荐，因为它是一个非标准的属性。推荐使用 Object.getPrototypeOf 和 Object.setPrototypeOf 方法来获取和设置对象的原型。</li><li><strong>继承链</strong>：当访问一个对象的属性时，如果该属性在对象自身不存在，JavaScript 引擎会通过 <strong>proto</strong> 属性在原型链上查找，直到找到该属性或到达原型链的末尾（null）。</li></ul><h2 id="构造函数" tabindex="-1">构造函数 <a class="header-anchor" href="#构造函数" aria-label="Permalink to &quot;构造函数&quot;">​</a></h2><p>构造函数和普通函数本质上没什么区别，只不过使用了new关键字创建对象的函数，被叫做了构造函数（首字母一般是大写，用以区分普通函数）。</p><div class="info custom-block"><p class="custom-block-title">使用 new 时构造函数内部操作过程</p><p>lobal Execution Conte</p><ol><li><strong>创建一个新对象</strong>：<br> 在内存中分配空间并创建一个新的空对象。</li><li><strong>设置原型</strong>：<br> 将新对象的 <strong>proto</strong> 属性设置为构造函数的 prototype 属性，从而建立新对象与构造函数原型之间的关联。</li><li><strong>绑定 this</strong>：<br> 将构造函数内部的 this 绑定到新创建的对象上，使得构造函数中的 this 指向这个新对象。</li><li><strong>执行构造函数内部代码</strong>：<br> 执行构造函数内部的代码，对新对象进行初始化。</li><li><strong>返回新对象</strong>：<br> 如果构造函数没有显式返回一个对象，则默认返回新创建的对象。如果构造函数显式返回一个对象，则返回该对象。</li></ol></div>',18),n=[s];function l(i,p,d,h,_,u){return t(),r("div",null,n)}const f=o(c,[["render",l]]);export{g as __pageData,f as default};
