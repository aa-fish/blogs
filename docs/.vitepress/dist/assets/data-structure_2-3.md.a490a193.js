import{_ as s,o as t,c as a,Q as n}from"./chunks/framework.5b0c684c.js";const e="/blogs/assets/data-structure_2-3_1.83ebf668.png",o="/blogs/assets/data-structure_2-3_2.b7a27d92.png",r="/blogs/assets/data-structure_2-3_3.01727e26.png",m=JSON.parse('{"title":"复杂度的渐进表示","description":"","frontmatter":{},"headers":[],"relativePath":"data-structure/2-3.md","filePath":"data-structure/2-3.md","lastUpdated":1729031503000}'),u={name:"data-structure/2-3.md"},l=n('<h1 id="复杂度的渐进表示" tabindex="-1">复杂度的渐进表示 <a class="header-anchor" href="#复杂度的渐进表示" aria-label="Permalink to &quot;复杂度的渐进表示&quot;">​</a></h1><div class="tip custom-block"><p class="custom-block-title">注意</p><p><strong>复杂度的表示法，钧以时间复杂度为例</strong></p></div><p>T(n) = O(f(n))表示存在常数C &gt; 0，n<sub>0</sub> &gt; 0 使得当 n &gt;= n<sub>0</sub>时有T(n) &lt;= C*f(n) <code>表示的T(n)的某种上界</code></p><p>T(n) = Ω(g(n))表示存在常数C &gt; 0，n<sub>0</sub> &gt; 0 使得当 n &gt;= n<sub>0</sub>时有T(n) &gt;= C*g(n) <code>表示的T(n)的某种下界</code></p><p>T(n) = Θ(h(n))表示同时有T(n) = O(h(n)) 和 T(n) = Ω(h(n)) <code>既是上界，也是下届，相当于是等价关系</code></p><hr><h2 id="不同复杂度函数的直观表现" tabindex="-1">不同复杂度函数的直观表现 <a class="header-anchor" href="#不同复杂度函数的直观表现" aria-label="Permalink to &quot;不同复杂度函数的直观表现&quot;">​</a></h2><p><img src="'+e+'" alt="图片描述"></p><p><img src="'+o+'" alt="图片描述"></p><p><img src="'+r+'" alt="图片描述"></p><p><strong>由上图不难看出，log n 是最好的函数</strong></p><h2 id="复杂度分析技巧" tabindex="-1">复杂度分析技巧 <a class="header-anchor" href="#复杂度分析技巧" aria-label="Permalink to &quot;复杂度分析技巧&quot;">​</a></h2><p><strong>两段算法</strong>分别有复杂度T<sub>1</sub>(n) = O(f<sub>1</sub>(n)) 和 T<sub>2</sub>(n) = O(f<sub>2</sub>(n))</p><ul><li>拼接：T<sub>1</sub>(n) + T<sub>2</sub>(n) = max(O(f<sub>1</sub>(n)) + O(f<sub>2</sub>(n)))</li><li>嵌套：T<sub>1</sub>(n) + T<sub>2</sub>(n) = O(f<sub>1</sub>(n)) * O(f<sub>2</sub>(n))</li></ul><p><strong>for循环</strong>的时间复杂度等于循环次数乘以循环体代码的复杂度。</p><p><strong>if-else</strong> 结构的复杂度取决于<code>if的条件判断复杂度</code>和<code>两个分支部分的复杂度</code>，总体复杂度取三者中最大的。</p><h2 id="复杂度分析" tabindex="-1">复杂度分析 <a class="header-anchor" href="#复杂度分析" aria-label="Permalink to &quot;复杂度分析&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">重要</p><p>算法实现的过程，复杂度分析的过程</p></div><p>[1,-2,6,-5,6,2,-3,8,-3,4,2,-1]</p><ul><li>方法一：所有的连续子列和都计算出来 O(n^3)</li><li>方法二：方法一优化一层 O(n^2)</li><li>方法三：分而治之 O(n*log n)</li><li>方法四：在线处理 O(n) （读）</li></ul>',20),c=[l];function i(p,b,d,_,g,h){return t(),a("div",null,c)}const T=s(u,[["render",i]]);export{m as __pageData,T as default};
