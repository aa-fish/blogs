import{_ as o,C as i,o as t,c,k as a,a as l,H as r,Q as p}from"./chunks/framework.5b0c684c.js";const s="/blogs/assets/GC_1-3_1.5fc51613.png",n="/blogs/assets/GC_1-3_2.6124acb4.png",T=JSON.parse('{"title":"GC","description":"","frontmatter":{},"headers":[],"relativePath":"web-optimization/GC/1-3.md","filePath":"web-optimization/GC/1-3.md","lastUpdated":1729031503000}'),d={name:"web-optimization/GC/1-3.md"},u=p("",53),h={class:"tip custom-block"},b=a("p",{class:"custom-block-title"},"写入屏障（write barriers）",-1),q=a("h2",{id:"三色标记法",tabindex:"-1"},[l("三色标记法 "),a("a",{class:"header-anchor",href:"#三色标记法","aria-label":'Permalink to "三色标记法"'},"​")],-1),m=a("p",null,"老生代是采用标记清理算法,在没有采用增量算法之前,单纯使用黑色和白色来标记数据就可以了,其标记流程即在一次执行完整的标记前,垃圾回收会将所有数据设置为白色,然后从根开始深度遍历,将所有能访问到的数据标记为黑色,标记为黑色的数据对象就是活动对象,剩余的白色数据对象也就是待清理的垃圾对象。",-1),_=a("p",null,"如果采用黑白的标记策略,那么垃圾回收器执行了一段增量回收后,暂停后启用主线程去执行了 JavaScript 应用程序,随后垃圾回收器再次被启动,这时候内存黑白色都有,我们便不能得知下一步走到哪里了。",-1),k=a("p",null,"为了解决这个问题,V8 团队采用了一种特殊方式,即 三色标记法,也就是使用每个对象的两个标记位和一个标记工作表来实现标记。",-1),f=a("p",null,"其中两个标记位编码三种颜色：白色（00），灰色（10）和黑色（11）。",-1),g=a("p",null,"最初所有的对象都是白色，意味着收集器还没有发现他们。当收集器发现一个对象时,将其标记为灰色并推入到标记工作表中。当收集器从标记工作表中弹出对象并访问他的所有字段时，灰色就会变成黑色。这种方案被称做 三色标记法。当没有灰色对象时,标记结束。所有剩余的白色对象无法达到，可以被安全的回收。",-1),v=a("p",null,"采用 三色标记法 后我们在恢复执行时就好办多了,可以直接通过当前内存中没有灰色节点来判断整个标记是否完成,如没有灰色节点,直接进入清理阶段,如还有灰色标记,恢复时直接从灰色的节点开始执行即可。",-1);function S(P,V,C,x,w,G){const e=i("lines");return t(),c("div",null,[u,a("div",h,[b,a("p",null,[l("内存屏障（英语：Memory barrier），也称内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，"),r(e,{text:"它使得 CPU 或编译器在对内存进行操作的时候, 严格按照一定的顺序来执行"}),l("。")])]),q,m,_,k,f,g,v])}const M=o(d,[["render",S]]);export{T as __pageData,M as default};
