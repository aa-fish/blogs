import{_ as a,o as s,c as t,Q as o}from"./chunks/framework.5b0c684c.js";const i="/blogs/assets/3DVisualization_graphics_7_1.00ebc164.png",l="/blogs/assets/3DVisualization_graphics_7_2.827de981.png",e="/blogs/assets/3DVisualization_graphics_7_3.0bea9906.png",p="/blogs/assets/3DVisualization_graphics_7_4.60352bb0.png",c="/blogs/assets/3DVisualization_graphics_7_5.d19626f6.png",r="/blogs/assets/3DVisualization_graphics_7_6.eca6e7ce.png",n="/blogs/assets/3DVisualization_graphics_7_7.7b01b72f.png",_="/blogs/assets/3DVisualization_graphics_7_8.725c978d.png",g="/blogs/assets/3DVisualization_graphics_7_9.5d73ca75.png",h="/blogs/assets/3DVisualization_graphics_7_10.08a54d87.png",d="/blogs/assets/3DVisualization_graphics_7_11.b6fc0c45.png",u="/blogs/assets/3DVisualization_graphics_7_12.3f7b0206.png",b="/blogs/assets/3DVisualization_graphics_7_13.c98cbda4.png",m="/blogs/assets/3DVisualization_graphics_7_14.686731b3.png",q="/blogs/assets/3DVisualization_graphics_7_15.20dc3d57.png",k="/blogs/assets/3DVisualization_graphics_7_16.bb81eb4e.png",V="/blogs/assets/3DVisualization_graphics_7_17.9a9296fe.png",f="/blogs/assets/3DVisualization_graphics_7_18.83d9b588.png",D="/blogs/assets/3DVisualization_graphics_7_19.b11637f4.png",z="/blogs/assets/3DVisualization_graphics_7_20.b5c6a5eb.png",x="/blogs/assets/3DVisualization_graphics_7_21.7627464e.png",P="/blogs/assets/3DVisualization_graphics_7_22.5a6b716d.png",A="/blogs/assets/3DVisualization_graphics_7_23.5f655dac.png",E=JSON.parse('{"title":"光线追踪","description":"","frontmatter":{},"headers":[],"relativePath":"3DVisualization/graphics/7-1.md","filePath":"3DVisualization/graphics/7-1.md","lastUpdated":1729031503000}'),B={name:"3DVisualization/graphics/7-1.md"},S=o('<h1 id="光线追踪" tabindex="-1">光线追踪 <a class="header-anchor" href="#光线追踪" aria-label="Permalink to &quot;光线追踪&quot;">​</a></h1><h2 id="光栅化存在的问题" tabindex="-1">光栅化存在的问题 <a class="header-anchor" href="#光栅化存在的问题" aria-label="Permalink to &quot;光栅化存在的问题&quot;">​</a></h2><p>使用光栅化的存在的一些缺陷：不能好的表示全局的效果。</p><ul><li>无法很好的做<code>软阴影</code>（后面改进才可以的，耗性能）。</li><li>无法很好的做<code>光泽反射</code>。</li><li>无法很好的做<code>间接光照</code>（多次反射）。</li></ul><h2 id="光线追踪存在的问题" tabindex="-1">光线追踪存在的问题 <a class="header-anchor" href="#光线追踪存在的问题" aria-label="Permalink to &quot;光线追踪存在的问题&quot;">​</a></h2><ul><li>光线追踪是准确的、质量高的，效果非常好，但非常慢，非常耗性能。</li></ul><blockquote><p>光线追踪更多的应用是<code>离线应用</code>。</p><p>~10K CPU核心小时，在生产中渲染一帧。</p></blockquote><h2 id="光线是什么" tabindex="-1">光线是什么？ <a class="header-anchor" href="#光线是什么" aria-label="Permalink to &quot;光线是什么？&quot;">​</a></h2><ul><li>光以直线传播（尽管这是错误的，它是一种波，这说它是直线也没什么问题）。</li><li>如果光线交叉，它们就不会相互“碰撞”（尽管这仍然是错误的）。</li><li>光线从光源传播到眼睛。（经过各种曲折的弹射过程，但是物理学在路径反转下是不变的----拥有可逆性）。</li></ul><h2 id="如何做光线追踪" tabindex="-1">如何做光线追踪？ <a class="header-anchor" href="#如何做光线追踪" aria-label="Permalink to &quot;如何做光线追踪？&quot;">​</a></h2><p><strong>利用的就是光线路径的可逆性</strong>。 <img src="'+i+'" alt=""> 首先是要做光线的投射：</p><blockquote><p>假设我们往一个虚拟的世界看，有一个成像的平面，被分割为很多的像素格子。</p><p>从相机出发，到达某一个像素点，连一条线。</p><p>然后把这个点与光源进行连线，这里是为了判断这个点是不是对于光源也可见，如果不在阴影里，那么我们就获得一条有效的光路（光源 --&gt; 物体 --&gt; 相机）。</p><p>有了光路我就可以计算这条光路的能量，从而计算像素点的颜色，再进行着色。</p></blockquote><p>在做光线追踪时存在一些假设：</p><ol><li>眼睛永远为一个针孔摄像机。（是一个点，暂时不考虑实际相机怎么处理）</li><li>光源也假设是个点光源。</li><li>对于物体遇到光线后，也假设会发生完美的折射或反射。</li></ol><p><img src="'+l+'" alt=""></p><blockquote><p>眼睛发出一条直线，相交于最近的点。</p></blockquote><p><img src="'+e+'" alt=""></p><blockquote><p>连线眼睛（相机） --&gt; 物体 --&gt; 光源，知道入射方向、折射方向、法线等信息，我们就计算像素点的颜色进行着色（例如Blinn Phong模型）</p></blockquote><p>上面描述的其实还是光线只弹射一次，下面开始 递归式（抖动式）光线追踪。</p><h2 id="递归式光线追踪-whitted-style" tabindex="-1">递归式光线追踪(Whitted-Style) <a class="header-anchor" href="#递归式光线追踪-whitted-style" aria-label="Permalink to &quot;递归式光线追踪(Whitted-Style)&quot;">​</a></h2><p><img src="'+p+'" alt=""> 上图不同年代花费的渲染时间：</p><blockquote><p>1979 -- 74m</p><p>2006 -- 6s</p><p>2012 -- 1/30s</p></blockquote><p><img src="'+c+'" alt=""><img src="'+r+'" alt=""><img src="'+n+'" alt=""><img src="'+_+'" alt=""><img src="'+g+'" alt=""></p><blockquote><p>折射和反射的时候都会发生能量的损失。</p><p>Whitted风格的像素颜色计算 会把一个点的多个计算结果加起来。</p></blockquote><h2 id="定义光线" tabindex="-1">定义光线 <a class="header-anchor" href="#定义光线" aria-label="Permalink to &quot;定义光线&quot;">​</a></h2><p>光线是由它的原点和一个方向向量来定义的。 <img src="'+h+'" alt=""></p><blockquote><p>从o 开始 往 d 方向 经过 t 时间。<strong>r</strong>(t) = <strong>o</strong> + t <strong>d</strong></p><p>这里相当于定义一条射线。</p></blockquote><h2 id="光线与球体的交点" tabindex="-1">光线与球体的交点 <a class="header-anchor" href="#光线与球体的交点" aria-label="Permalink to &quot;光线与球体的交点&quot;">​</a></h2><p><img src="'+d+'" alt=""></p><blockquote><p>光线：r(t) = o + t d, 0 &lt;= t &lt; ∞</p><p>球体：p : (p − c)<sup>2</sup> − R<sup>2</sup> = 0；这里是隐式定义：求上的任意点p到圆心的距离c = 半径R</p><p>如何表示他们的交点呢？这个交点应该是既在射线上也在球的表面上：(o + t d − c)<sup>2</sup> − R<sup>2</sup> = 0</p></blockquote><p><img src="'+u+'" alt=""></p><blockquote><p>计算 t</p></blockquote><h2 id="光线与一般性的隐式表面交点-推广" tabindex="-1">光线与一般性的隐式表面交点（推广） <a class="header-anchor" href="#光线与一般性的隐式表面交点-推广" aria-label="Permalink to &quot;光线与一般性的隐式表面交点（推广）&quot;">​</a></h2><p><img src="'+b+'" alt=""></p><h2 id="光线与显示表面求交点" tabindex="-1">光线与显示表面求交点 <a class="header-anchor" href="#光线与显示表面求交点" aria-label="Permalink to &quot;光线与显示表面求交点&quot;">​</a></h2><p><img src="'+m+'" alt=""></p><blockquote><p>一个简单的想法：只需把光线与每个三角形相交。简单，但缓慢（如何加速？---后面讲的<code>包围盒</code>）</p><p>可以有0或1个交叉点。</p></blockquote><p>如何做三角形与光线求交？ <img src="'+q+'" alt=""></p><blockquote><p>三角形与光线求交点其实就是：光线与一个平面求交点。</p><p>我们需要先定义一个平面。</p></blockquote><h2 id="定义平面" tabindex="-1">定义平面 <a class="header-anchor" href="#定义平面" aria-label="Permalink to &quot;定义平面&quot;">​</a></h2><p>平面可以由法向量和平面上的一个点来定义。 <img src="'+k+'" alt=""></p><blockquote><p>定义一个平面的法线向量（这里只能知道这个平面的朝向，它可以向着朝向移动，无法知道是哪一个平面）</p><p>还行需要定义个一点。（这个平面必须经过某一个点）</p><p>这样就能由<code>法向量</code>和<code>平面任意一个点</code>定义出一个平面。</p></blockquote><h2 id="光线与平面的交点" tabindex="-1">光线与平面的交点 <a class="header-anchor" href="#光线与平面的交点" aria-label="Permalink to &quot;光线与平面的交点&quot;">​</a></h2><p>同样的思想：交点既在平面上，也在光线上。 <img src="'+V+'" alt=""></p><p><strong>Möller-Trumbore算法</strong><img src="'+f+'" alt=""></p><h2 id="包围盒加速-aabb轴对齐包围盒" tabindex="-1">包围盒加速（AABB轴对齐包围盒） <a class="header-anchor" href="#包围盒加速-aabb轴对齐包围盒" aria-label="Permalink to &quot;包围盒加速（AABB轴对齐包围盒）&quot;">​</a></h2><p>如果光线不能与它的包围盒相交，则肯定无法与物体本身相交。 <img src="'+D+'" alt=""></p><p><strong>AABB轴对齐包围盒</strong><img src="'+z+'" alt=""></p><p><strong>如何判断光线与包围相交</strong><img src="'+x+'" alt=""></p><ul><li>只有当光线进入所有的对面，光线才会进入盒子。</li><li>只要光线离开任何一对面，光线就会离开盒子。</li><li>对于每一对面，各计算一次tmin和tmax（负数是可以的）。</li><li>计算出tmin和tmax，进入的时间求最大值，离开的时间求最小值。</li></ul><p><strong>tmin、tmax正负号情况</strong>： 应该检查t是否是负的物理正确性：因为光线并不是一条线，而是射线。 <img src="'+P+'" alt=""></p><blockquote><p><code>离开的时间</code> &lt; 0 ， 这个盒子就在射线的“后面”，不存在交点</p><p><code>进入的时间</code> &lt; 0 ，<code>离开的时间</code> &gt; 0 ，光线的原点在盒子里，有交叉点！</p><p><code>进入的时间</code> &lt; <code>离开的时间</code> <code>&amp;&amp;</code> <code>进入的时间</code> &gt;= 0 ，说明 光线在盒子里有段时间，有交叉点。</p></blockquote><p><strong>为什么使用包围盒</strong>？ <img src="'+A+'" alt=""></p>',53),T=[S];function y(R,$,C,N,W,v){return s(),t("div",null,T)}const I=a(B,[["render",y]]);export{E as __pageData,I as default};
