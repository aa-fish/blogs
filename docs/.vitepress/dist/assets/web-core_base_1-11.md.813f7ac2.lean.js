import{_ as e,C as p,o as t,c as r,k as s,a,H as n,Q as o}from"./chunks/framework.5b0c684c.js";const x=JSON.parse('{"title":"TypedArray","description":"","frontmatter":{},"headers":[],"relativePath":"web-core/base/1-11.md","filePath":"web-core/base/1-11.md","lastUpdated":1729031503000}'),c={name:"web-core/base/1-11.md"},y=s("h1",{id:"typedarray",tabindex:"-1"},[a("TypedArray "),s("a",{class:"header-anchor",href:"#typedarray","aria-label":'Permalink to "TypedArray"'},"​")],-1),E=s("code",null,"二进制数据缓冲区的类数组视图",-1),d=o("",6),i=s("ul",null,[s("li",null,"无符号整数数组（Uint8Array、Uint16Array、Uint32Array 和 BigUint64Array）直接以二进制形式存储数字。"),s("li",null,"有符号整数数组（Int8Array、Int16Array、Int32Array 和 BigInt64Array）使用二进制补码存储数字。"),s("li",null,"浮点数组（Float32Array 和 Float64Array）使用 IEEE 754浮点格式存储数字。"),s("li",null,"Uint8ClampedArray 是一种特殊情况。它像 Uint8Array 一样以二进制形式存储数字，但是当你存储超出范围的数字时，它会将数字钳制（clamp）到 0 到 255 的范围内，而不是截断最高有效位。")],-1),f=o("",26);function g(A,F,h,u,b,C){const l=p("lines");return t(),r("div",null,[y,s("p",null,[a("TypedArray 对象描述了底层"),E,a("。没有称为 TypedArray 的全局属性，也没有直接可用的 TypedArray 构造函数。"),n(l,{text:"是所有 TypedArray 子类的通用父类"}),a("。它只能通过子类对象原型链访问到，如：Object.getPrototypeOf(Int8Array)。")]),d,n(l,{text:"所有的`类型化数组`都是基于 ArrayBuffer 进行操作的，可以借此观察到每个元素的确切字节表示。因此二进制格式中的数字编码方式具有重要意义。"}),i,s("p",null,[a("Int8Array、Unit8Array 和 Uint8ClampedArray 以外的其他类型数组都将每个元素存储为多个字节。这些字节可以按照从最高有效位到最低有效位（大端序）或从最低有效位到最高有效位（小端序）的顺序进行排序。类型化数组始终使用平台的本机字节顺序。"),n(l,{text:"如果要在缓冲区中写入和读取时指定字节顺序，应该使用 DataView"}),a("。")]),s("p",null,[a("当向这些类型化数组写入时，"),n(l,{text:"超出可表示范围的值将被标准化"}),a("。")]),f])}const m=e(c,[["render",g]]);export{x as __pageData,m as default};
