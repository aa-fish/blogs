import{_ as s,o as t,c as o,Q as a}from"./chunks/framework.5b0c684c.js";const e="/blogs/assets/data-structure_3-6_1.4f8f38fe.png",c="/blogs/assets/data-structure_3-6_2.4124f1b0.png",l="/blogs/assets/data-structure_3-6_3.0578b230.png",r="/blogs/assets/data-structure_3-6_4.9b844e0b.png",p="/blogs/assets/data-structure_3-6_5.d71c6d77.png",d="/blogs/assets/data-structure_3-6_6.13ff96c8.png",i="/blogs/assets/data-structure_3-6_7.94f858f1.png",n="/blogs/assets/data-structure_3-6_8.ee5610c2.png",u="/blogs/assets/data-structure_3-6_9.666d8200.png",g="/blogs/assets/data-structure_3-6_10.054bd891.png",_="/blogs/assets/data-structure_3-6_14.72592ad2.png",m="/blogs/assets/data-structure_3-6_15.e088374f.png",b="/blogs/assets/data-structure_3-6_16.871a7a90.png",h="/blogs/assets/data-structure_3-6_17.eb794de4.png",k="/blogs/assets/data-structure_3-6_18.acbd65b5.png",q="/blogs/assets/data-structure_3-6_19.e2954329.png",f="/blogs/assets/data-structure_3-6_20.f0e1a09f.png",y="/blogs/assets/data-structure_3-6_11.783d70ba.png",T="/blogs/assets/data-structure_3-6_12.c26147c1.png",P="/blogs/assets/data-structure_3-6_13.86e7c456.png",x="/blogs/assets/data-structure_3-6_21.2b9780b0.png",v="/blogs/assets/data-structure_3-6_22.0c3ad2c6.png",B="/blogs/assets/data-structure_3-6_23.bf616e7d.png",L="/blogs/assets/data-structure_3-6_24.10d06564.png",R="/blogs/assets/data-structure_3-6_25.51c5e200.png",A="/blogs/assets/data-structure_3-6_26.16cf097e.png",F="/blogs/assets/data-structure_3-6_27.317c463a.png",S="/blogs/assets/data-structure_3-6_28.ede8e158.png",K="/blogs/assets/data-structure_3-6_29.fa65e108.png",N="/blogs/assets/data-structure_3-6_30.4880cf2e.png",V="/blogs/assets/data-structure_3-6_31.b2ea5ab1.png",D="/blogs/assets/data-structure_3-6_32.cadde002.png",$="/blogs/assets/data-structure_3-6_33.25a30e0a.png",E="/blogs/assets/data-structure_3-6_34.245cc0df.png",I="/blogs/assets/data-structure_3-6_35.35deb04b.png",C="/blogs/assets/data-structure_3-6_36.1dd69312.png",O="/blogs/assets/data-structure_3-6_37.91367f85.png",J="/blogs/assets/data-structure_3-6_38.60a8a18d.png",Q="/blogs/assets/data-structure_3-6_39.97dc7d07.png",ss=JSON.parse('{"title":"什么是树","description":"","frontmatter":{},"headers":[],"relativePath":"data-structure/3-6.md","filePath":"data-structure/3-6.md","lastUpdated":1729031503000}'),U={name:"data-structure/3-6.md"},j=a('<h1 id="什么是树" tabindex="-1">什么是树 <a class="header-anchor" href="#什么是树" aria-label="Permalink to &quot;什么是树&quot;">​</a></h1><h2 id="示例" tabindex="-1">示例 <a class="header-anchor" href="#示例" aria-label="Permalink to &quot;示例&quot;">​</a></h2><div class="info custom-block"><p class="custom-block-title">数据管理的基础操作查找【示例】</p><p><strong>查找</strong>：根据某个给定的<code>关键字K</code>，从<code>集合R</code>中找出与关键字K相同的值。</p><ul><li><code>静态查找</code>：集合记录是固定的，没有插入和删除操作，只有查找。（如：查字典）</li><li><code>动态查找</code>：集合记录是动态变化的，除了查找，还可能发生删除和插入操作。（如：借图书）</li></ul><div class="tip custom-block"><p class="custom-block-title"><strong>静态查找</strong></p><p><strong>静态查找-顺序查找</strong>：静态查找，最直接、最简单的方式就是<code>顺序查找</code>。</p><p><img src="'+e+'" alt="图片"></p><br><span class="line1">如果数据比较大，`顺序查找`往往不是效率最好的方法。 `二分查找` 的效率要遥遥领先。</span><br><br><p><strong>静态查找-二分查找</strong>：二分查找必须满足，1. 有序，2. 连续存储（数组） <img src="'+c+'" alt="图片"> 代码实现 <img src="'+l+'" alt="图片"></p></div></div><h2 id="分析" tabindex="-1">分析 <a class="header-anchor" href="#分析" aria-label="Permalink to &quot;分析&quot;">​</a></h2><p><img src="'+r+'" alt="图片"></p><h2 id="启示" tabindex="-1">启示 <a class="header-anchor" href="#启示" aria-label="Permalink to &quot;启示&quot;">​</a></h2><p>客观的世界中许多事物存在层次关系：</p><p>👉人类社会家谱；</p><p>👉社会组织结构；</p><p>👉图书信息管理；</p><p>这些其实都是<code>树</code>结构。<span class="lien1">分层次组织在管理上具有更高的效率。</span></p><p><strong>那么我们能不能把数据不存放在数组里面呢？我们就按照层次化结构来存数据，是不是也能达到我们想要的效果呢？按照层次化结构来存数据，这就是我们<code>查找树</code>的概念</strong>。</p><ul><li>查找树和二分查找在效率上可以达到相同效果。</li><li>查找树还可以解决我们另一个问题，<code>动态查</code>找的问题。</li></ul><h2 id="树" tabindex="-1">树 <a class="header-anchor" href="#树" aria-label="Permalink to &quot;树&quot;">​</a></h2><p><img src="'+p+'" alt="图片"></p><h2 id="树的定义" tabindex="-1">树的定义 <a class="header-anchor" href="#树的定义" aria-label="Permalink to &quot;树的定义&quot;">​</a></h2><p><strong>树（Tree）：n (n &gt;= 0)个节点构成的有限集合。</strong></p><p><strong>当n = 0时，称为空树。</strong></p><p><strong>当n &gt; 0时，对于一颗非空树，它具备一下性质：</strong></p><ol><li><p>树中有一个特殊结点称为“<code>根（Root）</code>”，用 <code>r</code>表示。</p></li><li><p>其余结点可分为m（m 0 ）个<code>互不相交</code>的有限集T<sub>1</sub>,T<sub>2</sub>...T<sub>m</sub>，其中每个集合本身又是一颗树，称为原来树的“<code>子树（SubTree）</code>”</p></li><li><p>子树不相交。</p></li><li><p>每个结点仅且仅有一个父结点（除根结点外）。</p></li><li><p>一颗N个结点的树有<code>N-1条边</code>（根结点没有）。</p></li></ol><h2 id="树的术语" tabindex="-1">树的术语 <a class="header-anchor" href="#树的术语" aria-label="Permalink to &quot;树的术语&quot;">​</a></h2><ol><li><code>结点的度（Degree）</code>：结点的子树个数。</li><li><code>树的度</code>：树的所有结点中最大的度数。</li><li><code>路径</code>：从A到K的路径为一个结点序列A，B，F，K（从上往下）。</li><li><code>路径长度</code>：路径所包含<code>边</code>的个数，为路径长度。</li><li><code>叶节点（Leaf</code>）：度为0的结点。</li><li><code>父结点</code>：直接的上下关系结点。</li><li><code>子结点</code>：直接的上下关系结点。</li><li><code>兄弟结点</code>：拥有同一个父结点。</li><li><code>祖先结点</code>：沿着根结点到某一个结点的路径上的所有结点，都是这个结点的祖先结点。</li><li><code>子孙结点</code>：某一个结点的子树所有结点，都是这个结点子孙结点。</li><li><code>结点的层次（Level）</code>：规定根结点在第1层，其他结点是父结点+1。</li><li><code>树的深度（Depth）</code>：树中所有结点中的最大层次是这颗树的深度。</li></ol><h2 id="树的表示" tabindex="-1">树的表示 <a class="header-anchor" href="#树的表示" aria-label="Permalink to &quot;树的表示&quot;">​</a></h2><p><strong>【数组】表示</strong>：如果使用数组实现，<span class="line1">有些情况会非常麻烦，且对程序设计也不友好</span>。</p><p><strong>【链表】表示</strong>：如果用链表实现，当结点结构不一致，对后续的程序设计造成负担。</p><p><img src="'+d+'" alt="图片"></p><p>如果使用3n个指针域，我们实际上只有n-1个边。也就是说会有，3n - (n -1)个空指针域，会造成空间浪费。</p><p><strong>【儿子-兄弟】表示</strong>：在链表的表示基础上做了优化，将每个结点设置成为统一的结构（包含两个指针的结构）。 <img src="'+i+'" alt="图片"><code>二叉树</code>结构，减少了空间的浪费，同时保证每个结点结构的统一，度为2。</p><h2 id="二叉树-t" tabindex="-1">二叉树（T） <a class="header-anchor" href="#二叉树-t" aria-label="Permalink to &quot;二叉树（T）&quot;">​</a></h2><p><strong>二叉树的定义</strong>：</p><blockquote><p><span class="line1">一个有穷的结点集合。这个集合可以为空，若不为空，则它由<code>根结点</code>和称为其<code>左子树</code>T<sub>L</sub>和<code>右子树</code>T<sub>R</sub>的两个不相交的二叉树组成。</span></p></blockquote><p><strong>二叉树基本形态</strong>： <img src="'+n+'" alt="图片"></p><p><strong>特殊二叉树</strong>： <img src="'+u+'" alt="图片"><img src="'+g+'" alt="图片"></p><p><strong>二叉树的几个重要性质</strong>：</p><p>🟥 一个二叉树第 i 层的最大结点数据为：<span class="line1"><strong>2<sup>i-1</sup>，i &gt;= 1</strong>。</span></p><blockquote><p>完美二叉树</p></blockquote><p>🟥 深度为 K 的二叉树的最大结点总数为：<span class="line1"><strong>2<sup>k</sup>-1，k &gt;= 1</strong>。</span></p><blockquote><p>1 + 2<sup>1</sup> + 2<sup>2</sup> + ... + 2<sup>k-1</sup> = 2<sup>k</sup> - 1</p></blockquote><p>🟥 任何非空二叉树T</p><blockquote><p>若n<sup>0</sup>表示叶节点，n<sup>1</sup>表示度为1的结点数，n<sup>2</sup>表示度为2的结点数。</p><p><span class="line1"><strong>一定存在 n<sub>0</sub> = n<sub>2</sub> + 1</strong></span></p></blockquote><h2 id="二叉树的抽象数据类型描述" tabindex="-1">二叉树的抽象数据类型描述 <a class="header-anchor" href="#二叉树的抽象数据类型描述" aria-label="Permalink to &quot;二叉树的抽象数据类型描述&quot;">​</a></h2><div class="info custom-block"><p class="custom-block-title">抽象数据类型描述</p><p>类型名称：二叉树</p><p>数据对象集：一个有穷的结点集合，若不为空，则由根结点和其左、右二叉子树组成。</p><p>操作集：BT ∈ BinTree，Item ∈ ElementType，重要操作有：</p><blockquote><ol><li><p>判别BT是否为空。</p></li><li><p>遍历，按某种顺序访问每一个结点。</p></li><li><p>创建一个二叉树。</p></li></ol></blockquote></div><h2 id="二叉树的遍历" tabindex="-1">二叉树的遍历 <a class="header-anchor" href="#二叉树的遍历" aria-label="Permalink to &quot;二叉树的遍历&quot;">​</a></h2><p><span class="line1">二叉树的遍历非常重要，很多算法设计都是建立在二叉树遍历的基础上的。</span></p><details class="details custom-block"><summary><code>先序</code>遍历：根、左子树、右子树；</summary><p><img src="'+_+'" alt="图片"></p></details><details class="details custom-block"><summary><code>中序</code>遍历：左子树、根、右子树；</summary><p><img src="'+m+'" alt="图片"></p></details><details class="details custom-block"><summary><code>后序</code>遍历：左子树、右子树、根；</summary><p><img src="'+b+'" alt="图片"></p></details><details class="details custom-block"><summary>注意</summary><p>🔴 先序、中序、后序都是基于递归的方法。 <img src="'+h+'" alt="图片"><br> 🔴 二叉树的<code>非递归</code>遍历，<code>使用栈</code>。</p><p><strong>非递归中序遍历算法【示例】</strong></p><blockquote><ol><li><p>遇到一个结点，就压入栈中，并去遍历它的左子树。</p></li><li><p>当左子树遍历结束，从它的栈顶弹除这个结点并访问它。</p></li><li><p>然后按其右指针再去中序遍历该结点的右子树。</p></li></ol><p><img src="'+k+'" alt="图片"></p></blockquote><p><span class="line1">非递归先序、后序遍历算法和非递归中序遍历算法大致一样，应为他们遍历路径是一样的。</span></p></details><details class="details custom-block"><summary><code>层次</code>遍历：从上到下、从左到右；</summary><p><strong>二叉树遍历的核心问题：<code>将二叉树二维结构的线性化</code></strong></p><blockquote><p><strong>问题</strong>：从结点访问其左、右儿子结点，当访问左儿子结点，右儿子结点（可能有多层）怎么办？</p><p><strong>解决</strong>：可以使用<code>栈</code>、<code>队列</code>的储存结构存储暂时不访问的结点。</p><p><strong>实现</strong>：从根结点开始遍历，首先将根结点加入队列。然后执行循环：结点出队，访问该结点，其左右儿子结点加入队列。 <img src="'+q+'" alt="图片"> 代码实现步骤 <img src="'+f+'" alt="图片"></p></blockquote></details><h2 id="二叉树的存储" tabindex="-1">二叉树的存储 <a class="header-anchor" href="#二叉树的存储" aria-label="Permalink to &quot;二叉树的存储&quot;">​</a></h2><details class="details custom-block"><summary>【数组实现二叉树存储】</summary><p><img src="'+y+'" alt="图片"><img src="'+T+'" alt="图片"></p></details><details class="details custom-block"><summary>【链表实现二叉树存储】</summary><p><img src="'+P+'" alt="图片"></p></details><h2 id="二叉树【题】" tabindex="-1">二叉树【题】 <a class="header-anchor" href="#二叉树【题】" aria-label="Permalink to &quot;二叉树【题】&quot;">​</a></h2><ol><li>给定一个二叉树，输出二叉树的中叶子结点。</li><li>给定一个二叉树，求二叉树的深度。</li><li>由两种遍历序列确定二叉树。</li><li>判断同构树。</li></ol><p>....</p><h2 id="二叉搜索树" tabindex="-1">二叉搜索树 <a class="header-anchor" href="#二叉搜索树" aria-label="Permalink to &quot;二叉搜索树&quot;">​</a></h2><p><strong>二叉搜索树，也称<code>二叉排序树</code>或<code>二叉查找树</code>。可以为空，当不空有以下性质：</strong></p><p>🔴 非空<code>左子树</code>的所有<code>键值</code>小于其<code>根结点</code>的<code>键值</code>。</p><p>🔴 非空<code>右子树</code>的所有<code>键值</code>大于其<code>根结点</code>的<code>键值</code>。</p><p>🔴 左、右子树都是二叉搜索树。</p><p><img src="'+x+'" alt="图片"></p><details class="details custom-block"><summary>二叉搜索树【查找、插入、删除】</summary><p><strong>查找</strong></p><blockquote><p><img src="'+v+'" alt="图片"><img src="'+B+'" alt="图片"><strong>递归实现的效率不高，<code>尾递归</code>一般都可以使用循环的方式实现。</strong><img src="'+L+'" alt="图片"></p></blockquote><blockquote><p><strong>最大值最小值查找</strong><img src="'+R+'" alt="图片"><img src="'+A+'" alt="图片"></p></blockquote><p><strong>插入</strong></p><blockquote><p><img src="'+F+'" alt="图片"><img src="'+S+'" alt="图片"><strong>删除</strong></p></blockquote><blockquote><p>叶节点（只有一个儿子结点）：找到后直接删除。</p><p>复杂情况：有枝叶结点（多个结点）。 <img src="'+K+'" alt="图片"><img src="'+N+'" alt="图片"></p></blockquote></details><h2 id="平衡二叉树" tabindex="-1">平衡二叉树 <a class="header-anchor" href="#平衡二叉树" aria-label="Permalink to &quot;平衡二叉树&quot;">​</a></h2><div class="info custom-block"><p class="custom-block-title">什么是平衡二叉树？</p><p><img src="'+V+'" alt="图片"></p><p>不同的插入次序，会生成不同的二叉树结构，有的查找快，有的查找慢。我们要怎么样设计，才能最优呢？→ <code>平衡二叉树</code></p></div><p><strong>平衡二叉树</strong>（Balanced Binary Tree）也叫AVL树，在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是O(logn)。</p><ul><li>为空时，叫空树。</li><li><span class="line1"> 不为空时，任一结点左、右子树<code>高度差</code>的绝对值不超过1，<code>|BF(T)| &lt;= 1</code>。 </span></li></ul><blockquote><p>BF(T) = h<sub>L</sub> - h<sub>R</sub>: <code>平衡因子(Balance Factor，简称BF)</code>，其中h<sub>L</sub>、h<sub>R</sub>分别为T的<code>左、右子树的高度</code>。</p></blockquote><p><img src="'+D+'" alt="图片"></p><p>平衡二叉树的高度能达到 log<sub>2</sub>n 吗？我们所希望的树能够平衡一点，树越平衡高度越低。</p><div class="info custom-block"><p class="custom-block-title">拓展</p><p><img src="'+$+'" alt="图片"><img src="'+E+'" alt="图片"></p></div><h2 id="平衡二叉树调整" tabindex="-1">平衡二叉树调整 <a class="header-anchor" href="#平衡二叉树调整" aria-label="Permalink to &quot;平衡二叉树调整&quot;">​</a></h2><p><strong>平衡二叉树调整有四个基本操作</strong></p><p>所有的平衡操作都依据<code>被破坏结点</code>（|BF(T)| &lt;= 1 这个不成立时）</p><details class="details custom-block"><summary>RR旋转（左左旋转）</summary><p><code>破坏者</code>插入在<code>被破坏者</code>的<code>右子树的右子树</code>上。 <img src="'+I+'" alt="图片"></p></details><details class="details custom-block"><summary>LL旋转（右右旋转）</summary><p><code>破坏者</code>插入在<code>被破坏者</code>的<code>左子树的左子树</code>上。 <img src="'+C+'" alt="图片"><img src="'+O+'" alt="图片"></p></details><details class="details custom-block"><summary>LR旋转（左右旋转）</summary><p><code>破坏者</code>插入在<code>被破坏者</code>的<code>左子树的右子树</code>上。 <img src="'+J+'" alt="图片"></p></details><details class="details custom-block"><summary>RL旋转（右左旋转）</summary><p><code>破坏者</code>插入在<code>被破坏者</code>的<code>右子树的左子树</code>上。 <img src="'+Q+'" alt="图片"></p></details>',77),w=[j];function z(G,H,M,W,X,Y){return t(),o("div",null,w)}const ts=s(U,[["render",z]]);export{ss as __pageData,ts as default};
