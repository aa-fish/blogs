import{_ as o,o as s,c as p,Q as a}from"./chunks/framework.5b0c684c.js";const t="/blogs/assets/3DVisualization_graphics_4_1-7.5faa12a0.png",i="/blogs/assets/3DVisualization_graphics_4_1-8.d30c1f9f.png",l="/blogs/assets/3DVisualization_graphics_4_1-9.a82ed6fe.png",c="/blogs/assets/3DVisualization_graphics_4_1-10.b8b3033a.png",e="/blogs/assets/3DVisualization_graphics_4_1-11.61d16c15.png",r="/blogs/assets/3DVisualization_graphics_4_1-12.3ecacb93.png",_="/blogs/assets/3DVisualization_graphics_4_1-13.98a95888.png",n="/blogs/assets/3DVisualization_graphics_4_2-1.008bd56c.png",g="/blogs/assets/3DVisualization_graphics_4_2-2.1f1b7015.png",u="/blogs/assets/3DVisualization_graphics_4_2-3.c3795372.png",b="/blogs/assets/3DVisualization_graphics_4_2-4.c69b2a3f.png",d="/blogs/assets/3DVisualization_graphics_4_2-5.8622911f.png",h="/blogs/assets/3DVisualization_graphics_4_2-6.b45f39c6.png",m="/blogs/assets/3DVisualization_graphics_4_2-7.ca155f1e.png",q="/blogs/assets/3DVisualization_graphics_4_2-8.dd9a761d.png",k="/blogs/assets/3DVisualization_graphics_4_2-9.342108d5.png",D="/blogs/assets/3DVisualization_graphics_4_2-10.c63ccc57.png",V="/blogs/assets/3DVisualization_graphics_4_2-11.e7d3aaef.png",f="/blogs/assets/3DVisualization_graphics_4_2-12.c67edaac.png",z="/blogs/assets/3DVisualization_graphics_4_2-13.d728dad1.png",x="/blogs/assets/3DVisualization_graphics_4_2-14.f64ec7d8.png",v="/blogs/assets/3DVisualization_graphics_4_2-15.96f8dc80.png",P="/blogs/assets/3DVisualization_graphics_4_2-16.58a9106d.png",M="/blogs/assets/3DVisualization_graphics_4_2-17.7411a1f3.png",A="/blogs/assets/3DVisualization_graphics_4_2-18.2c57f999.png",B="/blogs/assets/3DVisualization_graphics_4_2-19.22a661da.png",C="/blogs/assets/3DVisualization_graphics_4_2-20.7a0b905c.png",S="/blogs/assets/3DVisualization_graphics_4_2-21.8be508f7.png",T="/blogs/assets/3DVisualization_graphics_4_2-22.c5042c98.png",y="/blogs/assets/3DVisualization_graphics_4_2-23.611ebd62.png",N="/blogs/assets/3DVisualization_graphics_4_2-24.dd452675.png",U="/blogs/assets/3DVisualization_graphics_4_2-25.f4e94960.png",$="/blogs/assets/3DVisualization_graphics_4_2-26.6d89dc77.png",w="/blogs/assets/3DVisualization_graphics_4_2-27.3630e59d.png",E="/blogs/assets/3DVisualization_graphics_4_2-28.a5660f05.png",I="/blogs/assets/3DVisualization_graphics_4_2-29.f04b3ffd.png",G="/blogs/assets/3DVisualization_graphics_4_2-30.2c465d13.png",J="/blogs/assets/3DVisualization_graphics_4_2-31.eae974f6.png",L="/blogs/assets/3DVisualization_graphics_4_2-32.9bdd7d43.png",O="/blogs/assets/3DVisualization_graphics_4_2-33.810d5513.png",Q="/blogs/assets/3DVisualization_graphics_4_2-34.064206e4.png",R="/blogs/assets/3DVisualization_graphics_4_2-35.ac1d5aba.png",W="/blogs/assets/3DVisualization_graphics_4_2-36.5ea342e2.png",X="/blogs/assets/3DVisualization_graphics_4_2-37.02f0d644.png",j="/blogs/assets/3DVisualization_graphics_4_2-38.2fe1d81f.png",F="/blogs/assets/3DVisualization_graphics_4_2-39.eb8dbdd2.png",co=JSON.parse('{"title":"纹理映射","description":"","frontmatter":{},"headers":[],"relativePath":"3DVisualization/graphics/4-1-2.md","filePath":"3DVisualization/graphics/4-1-2.md","lastUpdated":1729031503000}'),H={name:"3DVisualization/graphics/4-1-2.md"},K=a('<h1 id="纹理映射" tabindex="-1">纹理映射 <a class="header-anchor" href="#纹理映射" aria-label="Permalink to &quot;纹理映射&quot;">​</a></h1><p><strong>纹理</strong>：是物体表面的特征信息。</p><blockquote><p>它可以是任何类型的图像、图案或模式，可以是静态的也可以是动态的，用来添加细节和丰富物体的外观。</p></blockquote><p><strong>材质</strong>：是物体本身的物理信息。</p><blockquote><p>如：颜色、光泽度、透明度、反射率和折射率...</p></blockquote><p><strong>着色</strong>：对不同的物体应用不同的材质的这么一个过程。</p><h2 id="着色器程序" tabindex="-1">着色器程序 <a class="header-anchor" href="#着色器程序" aria-label="Permalink to &quot;着色器程序&quot;">​</a></h2><ul><li>程序顶点和片元处理阶段。</li><li>描述在单个顶点（或碎片）上的操作。</li></ul><p><img src="'+t+'" alt=""></p><blockquote><p>着色器函数对每个片段执行一次。</p><p>输出在当前碎片的屏幕样本位置的表面颜色。</p><p>此着色器执行纹理查找以获取此时曲面的材质颜色，然后执行漫反射照明计算。</p></blockquote><p><a href="http://shadertoy.com/view/ld3Gz2" target="_blank" rel="noreferrer">着色器 - 传送门</a></p><p>着色器是一门值敬畏的语言，可以做出非常震撼的效果。</p><h2 id="纹理映射-纹理贴图" tabindex="-1">纹理映射（纹理贴图） <a class="header-anchor" href="#纹理映射-纹理贴图" aria-label="Permalink to &quot;纹理映射（纹理贴图）&quot;">​</a></h2><p>在三维空间中，每个三维曲面点在2D图像（纹理）中也有一个位置。 <img src="'+i+'" alt=""></p><p>应用于曲面的纹理： <img src="'+l+'" alt=""></p><blockquote><p>三维中的三角面，纹理中有对应的图形。</p></blockquote><h2 id="uv坐标" tabindex="-1">UV坐标 <a class="header-anchor" href="#uv坐标" aria-label="Permalink to &quot;UV坐标&quot;">​</a></h2><p>每个三角形顶点指定一个纹理坐标（u、v） <img src="'+c+'" alt=""></p><blockquote><p>绿色：v方向</p><p>红色：u方向</p></blockquote><p><strong>UV坐标的可视化</strong><img src="'+e+'" alt=""></p><p><img src="'+r+'" alt=""></p><p>好的纹理设计能无缝衔接。 <img src="'+_+'" alt=""></p><p>如果知道三角面的三个顶点的uv坐标，如何知道三角形内部每个像素的uv 坐标？</p><blockquote><p>可以通过插值的方式获得（利用重心坐标）</p></blockquote><h2 id="重心坐标" tabindex="-1">重心坐标 <a class="header-anchor" href="#重心坐标" aria-label="Permalink to &quot;重心坐标&quot;">​</a></h2><p>如何在三角形内部任意插值？为什么要在三角形内部插值？</p><blockquote><p>当我们知定顶点处的值，我们希望获得三角形内部的值。</p><p>并且在三角形内部获得平滑过渡的值。</p></blockquote><p>可以插值什么内容？</p><blockquote><p>纹理坐标，颜色，法向量 ……。</p></blockquote><p>怎么做呢？</p><blockquote><p>利用重心坐标。</p></blockquote><p><img src="'+n+'" alt=""></p><ul><li>重心坐标是定义在一个三角形内部的。</li><li>在三角内任意点与三个顶点的关系都可以表示成为一个线性组合：（x，y）= α A + β B + γ C</li><li>满足 α + β + γ = 1 ，α，β，γ 是三个非负数。当知道其中两个数后，就能得到第三个数。</li></ul><p><img src="'+g+'" alt=""> A点可以写成：</p><blockquote><p>(α, β, γ) = (1, 0, 0)</p><p>(x, y) = α A + β B + γ C = A</p></blockquote><p><strong>重心坐标也可以通过面积比求出</strong><img src="'+u+'" alt=""></p><p>三角形的重心点（通过面积求坐标） <img src="'+b+'" alt=""></p><p><strong>重心坐标计算公式</strong>：</p><p><img src="'+d+'" alt=""></p><p><strong>应用重心坐标做插值</strong>：</p><p><img src="'+h+'" alt=""></p><blockquote><p>重心坐标插值可以是：位置、纹理坐标、颜色、法线、深度、材质属性...</p></blockquote><div class="tip custom-block"><p class="custom-block-title">注意</p><p>重心坐标，在投影下会得到不一样的重心坐标。</p><p>如果我们想要插值三维空间中的属性，我们就应该取三维空间的中的顶点坐标，进行重心坐标计算和插值，而不等投影完成后。</p></div><h2 id="纹理映射过程" tabindex="-1">纹理映射过程 <a class="header-anchor" href="#纹理映射过程" aria-label="Permalink to &quot;纹理映射过程&quot;">​</a></h2><p><img src="'+m+'" alt=""></p><ul><li>对于任意一个点（x,y），可以使用<code>重心坐标</code>计算出它的<code>uv坐标</code>。</li><li>在纹理上查询uv坐标的值: <code>texcolor = texture.sample(u,v)</code></li><li>然后对该点的值进行处理。</li></ul><h2 id="纹理太小" tabindex="-1">纹理太小 <a class="header-anchor" href="#纹理太小" aria-label="Permalink to &quot;纹理太小&quot;">​</a></h2><p>纹理上的像素：纹素 / 纹理元素（texel）</p><p>如果纹理太小怎么办？（高像素的物体，低像素的纹理）</p><blockquote><p>纹理太小了，就会被拉大。</p><p>物体上每一个像素点我们都可以找到它对应的在纹理上的位置，但是在纹理上它可能不是整数，我们会把他四舍五入成为整数（0.4 = 0，0.6=1），在一定范围里，我们认为查找的是相同的纹理像素。 当纹理太小时，一定范围里的 pixel（3 * 3 或者 5 * 5） 会映射 同一个 texel。此时就会产生锯齿。</p></blockquote><p>如何解决这一问题？</p><p>当我们在查询纹理坐标的时候，如果获取到的是非整数坐标，我们要求取它的值，使得纹理更平滑。---- 使用<code>双线线插值</code>。</p><p><strong>双线性插值</strong></p><p>线性插值：</p><blockquote><p>lerp(x, v0, v1) = v0 + x(v1 − v0) （求 x 往哪个值靠近）</p><p>假设v0, v1分别是0，1，x 就是0-1之间的值。</p><p>当x = 0 的时候，x = v0；当x = 1 的时候，x = v1。</p></blockquote><p><img src="'+q+'" alt=""></p><p>双线性插值<br> 在水平方向和垂直方向做线性插值。 <img src="'+k+'" alt=""></p><blockquote><p>此时得到的纹理颜色就是周围四个点颜色的平均。</p></blockquote><p><img src="'+D+'" alt=""></p><blockquote><p>Nearest 四舍五入的方式</p><p>Bilinear 双线插值的效果</p><p>Bicubic 双线三次 （取周围16个点，运算量大，但精细）</p></blockquote><h2 id="纹理太大" tabindex="-1">纹理太大 <a class="header-anchor" href="#纹理太大" aria-label="Permalink to &quot;纹理太大&quot;">​</a></h2><p><img src="'+V+'" alt=""> 出现了 什么问题呢？</p><blockquote><p>远处摩尔纹</p><p>近处锯齿（走样）</p></blockquote><p>怎么产生的呢？ <img src="'+f+'" alt=""></p><blockquote><p>屏幕中，每个像素对应的纹理大小是各不相同的。</p><p>有的一个<code>像素</code>占用了很大一块<code>纹素</code>（如：1个像素点，在9个纹素点采样）</p><p>一个像素在一个很大区域的纹素中取平均，这个平均无法代表这个区域的纹素的。这会导致与上一个像素采样的不连续。</p></blockquote><p><strong>总结：像素 与 纹素 采样频率无法很好的匹配。（有的需要高频，有的需要低频）</strong></p><p>超采样会的效果怎样呢？</p><ul><li>质量高，但是昂贵。</li></ul><p>让我们用另一种方式来理解这个问题：</p><ul><li>如果我们不采样会怎样？</li><li>如果我们能立刻知道一个范围内的平均值即可。</li></ul><p><img src="'+z+'" alt=""></p><blockquote><p>这里就牵涉到 点查询、范围查询的问题。</p><p>图形学中用<code>Mipmap</code>来解决范围查询这一问题。</p></blockquote><p><img src="'+x+'" alt=""> 假设应用的是相同的纹理：</p><blockquote><p>近处的像素对应的纹素范围就小。</p><p>远处的像素对应的纹素范围就大。</p></blockquote><h2 id="mipmap" tabindex="-1">Mipmap <a class="header-anchor" href="#mipmap" aria-label="Permalink to &quot;Mipmap&quot;">​</a></h2><p>Mipmap的特点：</p><ul><li>fast：图形学中用<code>Mipmap</code>来解决范围查询，非常的快。</li><li>approx：近似（不是正确的）</li><li>square：方形。</li></ul><p>Mipmap只能做<code>近似的</code>、<code>方形的</code>、<code>快速的</code>范围查询。</p><p><img src="'+v+'" alt=""></p><blockquote><p>把一个纹理图片分成了多份。</p></blockquote><p>图像金字塔 <img src="'+P+'" alt=""></p><blockquote><p>Mipmap新增的存储开销比原来多了<code>三分之一</code>。</p></blockquote><p>我们要用Mipmap做一个近似的在正方形区域内做范围查询，且立刻要得到区域内的平均值是多少。</p><blockquote><p>任何一个像素都可以映射到一个纹理区域，这个区域我们要如何得到呢？我们可以用<code>近似</code>方法得到。</p></blockquote><p><img src="'+M+'" alt=""></p><blockquote><p>使用相邻像素样本的纹理坐标来估算纹理大小。（这里其实就是在一个“近似”）</p></blockquote><p><img src="'+A+'" alt=""><img src="'+B+'" alt=""> 这里非常有意思：</p><blockquote><p>上面的做的“近似”，其实就是在计算，一个像素，在纹理中所占纹素大小。</p><p>1个像素在屏幕中相当于是最小单位，“近似”做的事情就是将，<code>单位像素</code> 类比为 <code>单位纹理</code>----个人理解。</p></blockquote><p>在做完“近似”之后的正方形，我们如何根据我们之前预计算好的<code>Mipmap</code>进行查询这个正方形纹素区域的平均值呢？</p><blockquote><p>假设这个区域的大小是1像素，对应1*1个纹素，此时我们需要去<code>原始的纹理图层(D0)</code>中去找到这个对应的位置(一一对应)。</p><p>假设这个区域的大小是1像素，对应4*4的纹素，此时我们需要去<code>第三层纹理图层(D2)</code>中去找到这个对应的位置(一一对应)。</p><p>具体层级 D = log<sub>2</sub> L 。</p></blockquote><p><strong>不连续性问题</strong>： <img src="'+C+'" alt=""></p><blockquote><p>不连续性是应为Mipmap 只存在整数层，不存在小数层。</p><p>我们无法知道0.5层，0.8层对应的 Mipmap图层的值是什么？</p><p>三线性插值解决这个问题。</p></blockquote><p><strong>三线性插值</strong><img src="'+S+'" alt=""></p><blockquote><p>它可以得到非常平滑的值</p><p>首先它是做了相邻层级的区域查询，将其查询结果分别进行双线性插值</p><p>把相邻层级的两个双线插值结果合在一起。</p><p>然后再层与层之间再做插值。（在双线插值的基础上加了一层线性插值 = 三线性插值）</p><p>此时同过相同计算，我们就可以在任意层（管他是整数层，还是浮点数层）去查询它的值。</p></blockquote><p><strong>三线性插值的效果</strong><img src="'+T+'" alt=""></p><p><strong>三线性插值的开销</strong>：并不大。</p><blockquote><p>做两次查询。</p><p>一次插值。</p></blockquote><h2 id="各向异性过滤" tabindex="-1">各向异性过滤 <a class="header-anchor" href="#各向异性过滤" aria-label="Permalink to &quot;各向异性过滤&quot;">​</a></h2><p>Mipmap trilinear sampling 真的完美了吗？ <img src="'+y+'" alt=""></p><blockquote><p>Mipmap三线性插值： 远处的像素糊掉了。</p><p>各向异性过滤： 效果会好一些（各向异性过滤可以解决部分问题，任然存在一些问题）。</p></blockquote><p>各向异性：在不同方向上，它的表现各不相同。（水平和垂直方向上的表现完全不相同）</p><ul><li>在水平和垂直方向上进行压缩。</li></ul><p><img src="'+N+'" alt=""></p><blockquote><p>从水平方向看，高度不变。</p><p>从垂直方向看，宽度不变。</p><p><code>Mipmap</code>只是<code>各向异性过滤</code>对角线上的压缩，各向异性过滤比Mipmap多了是不均的水平方向和垂直方向的压缩。</p><p>将压缩的图片恢复到原来的图片，通过做这样的预计算，我们可以非常快查询到原始对应的图片被压缩后的矩形区域，而不是限制在Mipmap的正方形。</p></blockquote><p><img src="'+U+'" alt=""></p><blockquote><p>各向异性过滤对于矩阵区域可以快速的范围查询（比Mipmap好），不用限制在正方形区域，对于非矩阵的也没能解决。</p></blockquote><p><strong>各向异性过滤开销</strong>：是原来的三倍。</p><p>只要显存足够，各向异性过滤对应用的性能几乎没有什么影响。</p><p><strong>EWA过滤</strong>： <img src="'+$+'" alt=""></p><blockquote><p>效果好，代价是开销大。</p></blockquote><h2 id="纹理应用" tabindex="-1">纹理应用 <a class="header-anchor" href="#纹理应用" aria-label="Permalink to &quot;纹理应用&quot;">​</a></h2><p>在现代gpu中，纹理=内存+范围查询（过滤），不要把它局限于图片，可以把它理解成数据。</p><p><img src="'+w+'" alt=""> 环境贴图</p><blockquote><p>来自环境的光线与环境一起渲染。</p></blockquote><p><img src="'+E+'" alt=""> 环境照明</p><blockquote><p>环境贴图（左），用于渲染真实的照明。</p></blockquote><p>可以把<code>球面环境图</code>记录下来，并且可以展开。</p><p><strong>Spherical Map</strong><img src="'+I+'" alt=""><img src="'+G+'" alt=""></p><blockquote><p>容易变形（顶部和底部部分）被极度压缩。</p><p>这里就有了 <code>Cube Map</code>来解决 被压缩这一问题。</p></blockquote><p><strong>Cube Map</strong><img src="'+J+'" alt=""><img src="'+L+'" alt=""></p><h2 id="法线贴图-凹凸贴图" tabindex="-1">法线贴图（凹凸贴图） <a class="header-anchor" href="#法线贴图-凹凸贴图" aria-label="Permalink to &quot;法线贴图（凹凸贴图）&quot;">​</a></h2><p>人为的在任意点做一些虚拟的法线出来，通过纹理映射，得到凹凸不平的效果，物体几何本身是没有任何变化的。 <img src="'+O+'" alt=""></p><blockquote><p>假设左上的贴图：黑色部分为0，白色部分为1。</p><p>根据这些信息我们可以在这些位置重新构造出虚拟的法线，通过纹理映射得到凹凸不平的阴暗效果。</p></blockquote><p><strong>法线贴图具体做了什么事情</strong>？ <img src="'+Q+'" alt=""> 通过<code>法线贴图</code>添加曲面细节，而不添加更多的三角形，不会对原本的几何做改动。</p><blockquote><p>把任一像素的法线做一个绕动，通过定义临近位置的高度差，来重新计算它的法线。</p><p>应用<code>法线贴图</code>它会告诉我们高度位置会如何变化。（p的位置被向上移，法线指向n）</p></blockquote><p><strong>二维示例中：<code>法线贴图</code>如何计算法线</strong><img src="'+R+'" alt=""></p><blockquote><p>假设原本是平面P点，蓝色的曲线是<code>法线贴图</code>定义出来的。原本的法线为（0，1）</p><p>p点的<code>切线</code>计算为：p处的导数 dp = c * [h（p+1）- h (p)]</p><p>它的法线垂直于切线，把切线逆时针旋转90度就能得到它的法线。</p></blockquote><p><strong>三维中法线贴图</strong></p><ul><li>原始表面法线n (p) = （0，0，1）</li><li>uv方向的切线： <ul><li>dp/du = c1 * [h(u+1) - h(u)]</li><li>dp/dv = c2 * [h(v+1) - h(v)]</li></ul></li><li>法线为 (-dp/du, -dp/dv, 1).normalized()</li><li>请注意，这是在本地坐标中进行的！</li></ul><h2 id="位移贴图" tabindex="-1">位移贴图 <a class="header-anchor" href="#位移贴图" aria-label="Permalink to &quot;位移贴图&quot;">​</a></h2><p>位移贴图是 法线贴图（凹凸贴图）一种更高级的做法。</p><ul><li>位移贴图实际上是真是的改变了各个顶点的位置信息。</li><li>位移贴图对模型的三角面足够细致。 <img src="'+W+'" alt=""></li></ul><blockquote><p>可以从贴图边缘，和物体投影看出差异。</p></blockquote><p>如果一个物体模型三角面没有那么细致，能使用位移贴图吗？ <code>DirectX</code>（windows）提供了<code>动态曲面细分</code>方法。</p><h2 id="三维噪声函数" tabindex="-1">三维噪声函数 <a class="header-anchor" href="#三维噪声函数" aria-label="Permalink to &quot;三维噪声函数&quot;">​</a></h2><p>纹理可以是三维的 <img src="'+X+'" alt=""></p><blockquote><p>这里并没有二维纹理图像，而是定义了一个三维空间的噪声函数。</p><p>三维噪声函数还可以应用在山脉的起伏高度。</p></blockquote><h2 id="预先计算纹理" tabindex="-1">预先计算纹理 <a class="header-anchor" href="#预先计算纹理" aria-label="Permalink to &quot;预先计算纹理&quot;">​</a></h2><p><img src="'+j+'" alt=""></p><blockquote><p>把很多计算提前去做，做完了再去应用它，就会非常快了。</p><p>就是利用纹理去记录一些提前计算好的信息。</p></blockquote><h2 id="三维纹理和体积渲染" tabindex="-1">三维纹理和体积渲染 <a class="header-anchor" href="#三维纹理和体积渲染" aria-label="Permalink to &quot;三维纹理和体积渲染&quot;">​</a></h2><p><img src="'+F+'" alt=""></p><blockquote><p>如：通过核磁共振扫描得到一些三维的信息（组织的密度...），然后渲染出这些信息。</p></blockquote>',143),Y=[K];function Z(oo,so,po,ao,to,io){return s(),p("div",null,Y)}const eo=o(H,[["render",Z]]);export{co as __pageData,eo as default};
