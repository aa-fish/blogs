import{_ as t,o as a,c as e,Q as s}from"./chunks/framework.5b0c684c.js";const o="/blogs/assets/data-structure_4-4_1.d789303f.png",r="/blogs/assets/data-structure_4-4_2.6af57949.png",c="/blogs/assets/data-structure_4-4_3.11220734.png",l="/blogs/assets/data-structure_4-4_4.ac229f42.png",k=JSON.parse('{"title":"希尔排序","description":"","frontmatter":{},"headers":[],"relativePath":"data-structure/4-4.md","filePath":"data-structure/4-4.md","lastUpdated":1729031503000}'),_={name:"data-structure/4-4.md"},u=s('<h1 id="希尔排序" tabindex="-1">希尔排序 <a class="header-anchor" href="#希尔排序" aria-label="Permalink to &quot;希尔排序&quot;">​</a></h1><ul><li>利用<code>插入排序</code>的简单；</li><li>克服<code>插入排序</code>每次只交换一次的缺点（每次交换一个逆序对）；</li></ul><p><img src="'+o+'" alt="图片"></p><br><h2 id="原始希尔增量序列" tabindex="-1">原始希尔增量序列： <a class="header-anchor" href="#原始希尔增量序列" aria-label="Permalink to &quot;原始希尔增量序列：&quot;">​</a></h2><p><strong>D<sub>m</sub> = [N / 2]，D<sub>k</sub> = [D <sub>k+1</sub> / 2]</strong></p><ul><li>算法实现:</li></ul><blockquote><p><img src="'+r+'" alt="图片"></p></blockquote><ul><li>最坏情况的增量序列:</li></ul><blockquote><p><img src="'+c+'" alt="图片"> 原因是有些增量序列不起作用；</p></blockquote><br><h2 id="更多的增量序列" tabindex="-1">更多的增量序列 <a class="header-anchor" href="#更多的增量序列" aria-label="Permalink to &quot;更多的增量序列&quot;">​</a></h2><blockquote><p><img src="'+l+'" alt="图片"></p></blockquote>',13),i=[u];function n(d,p,b,h,m,g){return a(),e("div",null,i)}const q=t(_,[["render",n]]);export{k as __pageData,q as default};
