import{_ as t,o as a,c as s,Q as e}from"./chunks/framework.5b0c684c.js";const o="/blogs/assets/data-structure_3-8_1.7a725e11.png",r="/blogs/assets/data-structure_3-8_2.df155d99.png",c="/blogs/assets/data-structure_3-8_3.51d69438.png",_="/blogs/assets/data-structure_3-8_4.1940d9bb.png",d="/blogs/assets/data-structure_3-8_5.9e9395b4.png",i="/blogs/assets/data-structure_3-8_6.6f6dfc1a.png",n="/blogs/assets/data-structure_3-8_7.a7292538.png",l="/blogs/assets/data-structure_3-8_8.2d223218.png",p="/blogs/assets/data-structure_3-8_9.46894357.png",u="/blogs/assets/data-structure_3-8_10.fdab2124.png",m="/blogs/assets/data-structure_3-8_11.e7020f0f.png",g="/blogs/assets/data-structure_3-8_12.1cc1a947.png",$=JSON.parse('{"title":"什么是哈夫曼树","description":"","frontmatter":{},"headers":[],"relativePath":"data-structure/3-8.md","filePath":"data-structure/3-8.md","lastUpdated":1729031503000}'),h={name:"data-structure/3-8.md"},b=e('<h1 id="什么是哈夫曼树" tabindex="-1">什么是哈夫曼树 <a class="header-anchor" href="#什么是哈夫曼树" aria-label="Permalink to &quot;什么是哈夫曼树&quot;">​</a></h1><h2 id="示例" tabindex="-1">示例 <a class="header-anchor" href="#示例" aria-label="Permalink to &quot;示例&quot;">​</a></h2><div class="info custom-block"><p class="custom-block-title">考试成级查找【示例】</p><p><img src="'+o+'" alt="图片"><img src="'+r+'" alt="图片"></p><p>这样的效率并不是最优的，有没有更好的方法？下面我们对判断树进行优化。</p><p><img src="'+c+'" alt="图片"></p><p>示例中的<code>效率</code>也就是，<code>带权路径长度</code>。</p></div><h2 id="定义" tabindex="-1">定义 <a class="header-anchor" href="#定义" aria-label="Permalink to &quot;定义&quot;">​</a></h2><p>给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的<span class="line1">带权路径长度达到最小</span>，称这样的二叉树为<code>最优二叉树</code>，也称为<code>哈夫曼树(Huffman Tree)</code>。</p><p><strong>哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近</strong>。</p><p><img src="'+_+'" alt="图片"> WPL <img src="'+d+'" alt="图片"></p><h2 id="哈夫曼树构造" tabindex="-1">哈夫曼树构造 <a class="header-anchor" href="#哈夫曼树构造" aria-label="Permalink to &quot;哈夫曼树构造&quot;">​</a></h2><p>每次把<code>权值最小的两棵二叉树</code>合并，且<code>权值最小的两棵二叉树</code>的<code>和</code>继续与后面的数比较，选出两个最小的数重复以上操作步骤。整体复杂度为O(NlogN) <img src="'+i+'" alt="图片"><img src="'+n+'" alt="图片"></p><h2 id="哈夫曼数特点" tabindex="-1">哈夫曼数特点 <a class="header-anchor" href="#哈夫曼数特点" aria-label="Permalink to &quot;哈夫曼数特点&quot;">​</a></h2><p><img src="'+l+'" alt="图片"></p><h2 id="哈夫曼编码" tabindex="-1">哈夫曼编码 <a class="header-anchor" href="#哈夫曼编码" aria-label="Permalink to &quot;哈夫曼编码&quot;">​</a></h2><p><img src="'+p+'" alt="图片"><img src="'+u+'" alt="图片"></p><p><code>前缀码</code>prefix code：任何字符的编码都不是另一个字符编码的前缀（可以无二意的解码）。 <img src="'+m+'" alt="图片"><img src="'+g+'" alt="图片"></p>',14),f=[b];function q(P,k,x,N,T,S){return a(),s("div",null,f)}const A=t(h,[["render",q]]);export{$ as __pageData,A as default};
