import{_ as e,C as p,o as t,c as r,k as s,a,H as n,Q as o}from"./chunks/framework.5b0c684c.js";const x=JSON.parse('{"title":"TypedArray","description":"","frontmatter":{},"headers":[],"relativePath":"web-core/base/1-11.md","filePath":"web-core/base/1-11.md","lastUpdated":1729031503000}'),c={name:"web-core/base/1-11.md"},y=s("h1",{id:"typedarray",tabindex:"-1"},[a("TypedArray "),s("a",{class:"header-anchor",href:"#typedarray","aria-label":'Permalink to "TypedArray"'},"​")],-1),E=s("code",null,"二进制数据缓冲区的类数组视图",-1),d=o(`<h2 id="typedarray子类对象" tabindex="-1">TypedArray子类对象 <a class="header-anchor" href="#typedarray子类对象" aria-label="Permalink to &quot;TypedArray子类对象&quot;">​</a></h2><table><thead><tr><th style="text-align:left;">类型</th><th style="text-align:left;">值范围</th><th style="text-align:left;">字节大小</th><th style="text-align:left;">描述</th><th style="text-align:left;">Web IDL 类型</th><th style="text-align:left;">等价的 C 类型</th></tr></thead><tbody><tr><td style="text-align:left;"><code>Int8Array</code></td><td style="text-align:left;">-128 ~ 127</td><td style="text-align:left;">1</td><td style="text-align:left;">8 位有符号整型（补码）</td><td style="text-align:left;"><code>byte</code></td><td style="text-align:left;"><code>int8_t</code></td></tr><tr><td style="text-align:left;"><code>Uint8Array</code></td><td style="text-align:left;">0 ~ 255</td><td style="text-align:left;">1</td><td style="text-align:left;">8 位无符号整型</td><td style="text-align:left;"><code>octet</code></td><td style="text-align:left;"><code>uint8_t</code></td></tr><tr><td style="text-align:left;"><code>Uint8ClampedArray</code></td><td style="text-align:left;">0 ~ 255</td><td style="text-align:left;">1</td><td style="text-align:left;">8 位无符号整型（一定在 0 ~ 255 之间）</td><td style="text-align:left;"><code>octet</code></td><td style="text-align:left;"><code>uint8_t</code></td></tr><tr><td style="text-align:left;"><code>Int16Array</code></td><td style="text-align:left;">-32768 ~ 32767</td><td style="text-align:left;">2</td><td style="text-align:left;">16 位有符号整型（补码）</td><td style="text-align:left;"><code>short</code></td><td style="text-align:left;"><code>int16_t</code></td></tr><tr><td style="text-align:left;"><code>Uint16Array</code></td><td style="text-align:left;">0 ~ 65535</td><td style="text-align:left;">2</td><td style="text-align:left;">16 位无符号整型</td><td style="text-align:left;"><code>unsigned short</code></td><td style="text-align:left;"><code>uint16_t</code></td></tr><tr><td style="text-align:left;"><code>Int32Array</code></td><td style="text-align:left;">-2147483648 ~ 2147483647</td><td style="text-align:left;">4</td><td style="text-align:left;">32 位有符号整型（补码）</td><td style="text-align:left;"><code>long</code></td><td style="text-align:left;"><code>int32_t</code></td></tr><tr><td style="text-align:left;"><code>Uint32Array</code></td><td style="text-align:left;">0 ~ 4294967295</td><td style="text-align:left;">4</td><td style="text-align:left;">32 位无符号整型</td><td style="text-align:left;"><code>unsigned long</code></td><td style="text-align:left;"><code>uint32_t</code></td></tr><tr><td style="text-align:left;"><code>Float32Array</code></td><td style="text-align:left;"><code>-3.4E38</code> ~ <code>3.4E38</code>(最小正数1.2E-38)</td><td style="text-align:left;">4</td><td style="text-align:left;">32 位 IEEE 浮点数（7 位有效数字）</td><td style="text-align:left;"><code>unrestricted float</code></td><td style="text-align:left;"><code>float</code></td></tr><tr><td style="text-align:left;"><code>Float64Array</code></td><td style="text-align:left;"><code>-1.8E308</code> ~ <code>1.8E308</code>(最小正数5E-324)</td><td style="text-align:left;">8</td><td style="text-align:left;">64 位 IEEE 浮点数（16 位有效数字）</td><td style="text-align:left;"><code>unrestricted double</code></td><td style="text-align:left;"><code>double</code></td></tr><tr><td style="text-align:left;"><code>BigInt64Array</code></td><td style="text-align:left;">-263 ~ 263 - 1</td><td style="text-align:left;">8</td><td style="text-align:left;">64 位有符号整型（补码）</td><td style="text-align:left;"><code>bigint</code></td><td style="text-align:left;"><code>int64_t</code></td></tr><tr><td style="text-align:left;"><code>BigUint64Array</code></td><td style="text-align:left;">0 ~ 264 - 1</td><td style="text-align:left;">8</td><td style="text-align:left;">64 位无符号整型</td><td style="text-align:left;"><code>bigint</code></td><td style="text-align:left;"><code>uint64_t</code></td></tr></tbody></table><h2 id="typedarray构造函数" tabindex="-1">TypedArray构造函数 <a class="header-anchor" href="#typedarray构造函数" aria-label="Permalink to &quot;TypedArray构造函数&quot;">​</a></h2><ul><li>TypedArray本身是没有构造函数的，TypedArray是其子类的父类</li><li>该对象不能被直接实例化，试图去使用 new 构造它将会抛出TypeError。所有 TypedArray 子类的构造函数只能使用 new 构造。</li></ul><div class="tip custom-block"><p class="custom-block-title">下面 TypedArray 是一个具体的构造函数。可以理解为是TypedArray的任意子类（11个）</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">TypedArray</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">TypedArray</span><span style="color:#E1E4E8;">(object)</span></span>
<span class="line"><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">TypedArray</span><span style="color:#E1E4E8;">(length)</span></span>
<span class="line"><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">TypedArray</span><span style="color:#E1E4E8;">(typedArray)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">TypedArray</span><span style="color:#E1E4E8;">(buffer)</span></span>
<span class="line"><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">TypedArray</span><span style="color:#E1E4E8;">(buffer, byteOffset)</span></span>
<span class="line"><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">TypedArray</span><span style="color:#E1E4E8;">(buffer, byteOffset, length)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">TypedArray</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">TypedArray</span><span style="color:#24292E;">(object)</span></span>
<span class="line"><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">TypedArray</span><span style="color:#24292E;">(length)</span></span>
<span class="line"><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">TypedArray</span><span style="color:#24292E;">(typedArray)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">TypedArray</span><span style="color:#24292E;">(buffer)</span></span>
<span class="line"><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">TypedArray</span><span style="color:#24292E;">(buffer, byteOffset)</span></span>
<span class="line"><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">TypedArray</span><span style="color:#24292E;">(buffer, byteOffset, length)</span></span></code></pre></div><p><strong>参数情况</strong>：</p><p><code>object</code>：当使用的不是 TypedArray 实例的对象调用时，与 TypedArray.from() 方法相同的方式创建一个新的类型化数组。</p><p><code>typedArray</code>：当使用 TypedArray 子类的实例调用时，typedArray 会被拷贝到一个新的类型数组中。</p><blockquote><ul><li>对于非 bigint TypeedArray 构造函数，typedArray 参数仅可以是非 bigint 类型（例如 Int32Array）。</li><li>对于 bigint TypedArray 构造函数（BigInt64Array 或 BigUint64Array），typedArray 参数仅可以是 bigint 类型。</li><li>typedArray 中的每个值在拷贝到新数组之前都转换为构造函数的相应类型。新的类型化数组的长度与 typedArray 参数的长度相同。</li></ul></blockquote><p><code>length[可选]</code>： 当使用非对象调用时，该参数将被视为指定类型化数组长度的数字。在内存中创建一个内部数组缓冲区，大小长度乘以 BYTES_PER_ELEMENT 字节，用 0 填充。省略所有参数，等同于使用 0 作为参数。</p><p><code>buffer、byteOffset[可选]、length[可选]</code>： 当使用 ArrayBuffer 或 SharedArrayBuffer 实例以及可选的 byteOffset 和 length 参数调用时，将创建一个新的指定缓冲区的类型化数组视图。byteOffset 和 length 参数指定类型化数组视图将暴露的内存范围。</p><blockquote><ul><li>如果忽略这两个参数，则是整个视图的所有 buffer；</li><li>如果仅忽略 length，则是从 byteOffset 开始的 buffer 剩余部分的视图。</li></ul></blockquote></div><h2 id="值编码与标准化" tabindex="-1">值编码与标准化 <a class="header-anchor" href="#值编码与标准化" aria-label="Permalink to &quot;值编码与标准化&quot;">​</a></h2>`,6),i=s("ul",null,[s("li",null,"无符号整数数组（Uint8Array、Uint16Array、Uint32Array 和 BigUint64Array）直接以二进制形式存储数字。"),s("li",null,"有符号整数数组（Int8Array、Int16Array、Int32Array 和 BigInt64Array）使用二进制补码存储数字。"),s("li",null,"浮点数组（Float32Array 和 Float64Array）使用 IEEE 754浮点格式存储数字。"),s("li",null,"Uint8ClampedArray 是一种特殊情况。它像 Uint8Array 一样以二进制形式存储数字，但是当你存储超出范围的数字时，它会将数字钳制（clamp）到 0 到 255 的范围内，而不是截断最高有效位。")],-1),f=o(`<ul><li>所有整数数组（Uint8ClampedArray 除外）都使用固定宽度数值转换，首先截断数字的小数部分，然后取最低位。</li><li>Uint8ClampedArray 首先将数字钳制到 0 到 255 的范围内（大于 255 的值变为 255，小于 0 的值变为 0），然后使用银行家舍入法将结果四舍五入（而非向下取整）到最近的整数，也就是说，如果数字恰好在两个整数之间，它将四舍五入到最近的偶数。（例如，0.5 变为 0，1.5 变为 2，2.5 变为 2。）</li><li>Float32Array 使用“银行家舍入法”将 64 位浮点数转换为 32 位。这与 Math.fround() 提供的算法相同。</li></ul><h2 id="底层为可变大小缓冲时的行为" tabindex="-1">底层为可变大小缓冲时的行为 <a class="header-anchor" href="#底层为可变大小缓冲时的行为" aria-label="Permalink to &quot;底层为可变大小缓冲时的行为&quot;">​</a></h2><p>当一个 TypedArray 被创建为一个可变大小缓冲的视图时，改变底层缓冲的大小会对 TypedArray 的大小产生不同的影响，这取决于 TypedArray 是否是长度跟踪的。</p><div class="info custom-block"><p class="custom-block-title">INFO</p><ol><li>如果一个<code>类型化数组</code>是通过省略或传递 undefined 给第三个参数来创建的，那么它将跟踪长度，并且将自动调整大小以适应底层 buffer 的大小</li></ol><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">buffer</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ArrayBuffer</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">8</span><span style="color:#E1E4E8;">, { maxByteLength: </span><span style="color:#79B8FF;">16</span><span style="color:#E1E4E8;"> });</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">float32</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Float32Array</span><span style="color:#E1E4E8;">(buffer);</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(float32.byteLength); </span><span style="color:#6A737D;">// 8</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(float32.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// 2</span></span>
<span class="line"><span style="color:#E1E4E8;">buffer.</span><span style="color:#B392F0;">resize</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">12</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(float32.byteLength); </span><span style="color:#6A737D;">// 12</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(float32.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// 3</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">buffer</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ArrayBuffer</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">8</span><span style="color:#24292E;">, { maxByteLength: </span><span style="color:#005CC5;">16</span><span style="color:#24292E;"> });</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">float32</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Float32Array</span><span style="color:#24292E;">(buffer);</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(float32.byteLength); </span><span style="color:#6A737D;">// 8</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(float32.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;">); </span><span style="color:#6A737D;">// 2</span></span>
<span class="line"><span style="color:#24292E;">buffer.</span><span style="color:#6F42C1;">resize</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">12</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(float32.byteLength); </span><span style="color:#6A737D;">// 12</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(float32.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;">); </span><span style="color:#6A737D;">// 3</span></span></code></pre></div><ol start="2"><li>如果一个类型化数组是通过使用第三个 length 参数指定大小创建时，则它的大小不会随着 buffer 大小的增长而改变：</li></ol><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">buffer</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ArrayBuffer</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">8</span><span style="color:#E1E4E8;">, { maxByteLength: </span><span style="color:#79B8FF;">16</span><span style="color:#E1E4E8;"> });</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">float32</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Float32Array</span><span style="color:#E1E4E8;">(buffer, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(float32.byteLength); </span><span style="color:#6A737D;">// 8</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(float32.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// 2</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(float32[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">]); </span><span style="color:#6A737D;">// 0, 初始值</span></span>
<span class="line"><span style="color:#E1E4E8;">buffer.</span><span style="color:#B392F0;">resize</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">12</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(float32.byteLength); </span><span style="color:#6A737D;">// 8</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(float32.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// 2</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(float32[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">]); </span><span style="color:#6A737D;">// 0, 初始值</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">buffer</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ArrayBuffer</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">8</span><span style="color:#24292E;">, { maxByteLength: </span><span style="color:#005CC5;">16</span><span style="color:#24292E;"> });</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">float32</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Float32Array</span><span style="color:#24292E;">(buffer, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(float32.byteLength); </span><span style="color:#6A737D;">// 8</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(float32.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;">); </span><span style="color:#6A737D;">// 2</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(float32[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">]); </span><span style="color:#6A737D;">// 0, 初始值</span></span>
<span class="line"><span style="color:#24292E;">buffer.</span><span style="color:#6F42C1;">resize</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">12</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(float32.byteLength); </span><span style="color:#6A737D;">// 8</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(float32.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;">); </span><span style="color:#6A737D;">// 2</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(float32[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">]); </span><span style="color:#6A737D;">// 0, 初始值</span></span></code></pre></div><ol start="3"><li>当 buffer 缩小时，其上的类型化数组可能会超出范围，在这种情况下，类型化数组的观测大小将减少为 0。这是非长度跟踪类型化数组唯一可能改变长度的情况。如果你随后再次增长 buffer 以使类型化数组回到范围内，类型化数组的大小将恢复到其原始值。长度跟踪的类型化数组，如果 buffer 被缩小到小于 byteOffset，也会发生同样的事情。</li></ol><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">buffer</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ArrayBuffer</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">8</span><span style="color:#E1E4E8;">, { maxByteLength: </span><span style="color:#79B8FF;">16</span><span style="color:#E1E4E8;"> });</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">float32</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Float32Array</span><span style="color:#E1E4E8;">(buffer, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#6A737D;">// buffer 缩小</span></span>
<span class="line"><span style="color:#E1E4E8;">buffer.</span><span style="color:#B392F0;">resize</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">7</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(float32.byteLength); </span><span style="color:#6A737D;">// 0</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(float32.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// 0</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(float32[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">]); </span><span style="color:#6A737D;">// undefinedv</span></span>
<span class="line"><span style="color:#6A737D;">// 恢复到其原始值</span></span>
<span class="line"><span style="color:#E1E4E8;">buffer.</span><span style="color:#B392F0;">resize</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">8</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(float32.byteLength); </span><span style="color:#6A737D;">// 8</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(float32.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// 2</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(float32[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">]); </span><span style="color:#6A737D;">// 0 - 又回到范围内了！</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">buffer</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ArrayBuffer</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">8</span><span style="color:#24292E;">, { maxByteLength: </span><span style="color:#005CC5;">16</span><span style="color:#24292E;"> });</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">float32</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Float32Array</span><span style="color:#24292E;">(buffer, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#6A737D;">// buffer 缩小</span></span>
<span class="line"><span style="color:#24292E;">buffer.</span><span style="color:#6F42C1;">resize</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">7</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(float32.byteLength); </span><span style="color:#6A737D;">// 0</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(float32.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;">); </span><span style="color:#6A737D;">// 0</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(float32[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">]); </span><span style="color:#6A737D;">// undefinedv</span></span>
<span class="line"><span style="color:#6A737D;">// 恢复到其原始值</span></span>
<span class="line"><span style="color:#24292E;">buffer.</span><span style="color:#6F42C1;">resize</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">8</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(float32.byteLength); </span><span style="color:#6A737D;">// 8</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(float32.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;">); </span><span style="color:#6A737D;">// 2</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(float32[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">]); </span><span style="color:#6A737D;">// 0 - 又回到范围内了！</span></span></code></pre></div><ol start="4"><li>长度跟踪的类型化数组，如果 buffer 被缩小到小于 byteOffset，也会发生同样的事情。</li></ol><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">buffer</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ArrayBuffer</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">8</span><span style="color:#E1E4E8;">, { maxByteLength: </span><span style="color:#79B8FF;">16</span><span style="color:#E1E4E8;"> });</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">float32</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Float32Array</span><span style="color:#E1E4E8;">(buffer, </span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#6A737D;">// float32 是长度跟踪的，但它只从第 4 个字节开始，直到缓冲的结尾，</span></span>
<span class="line"><span style="color:#6A737D;">// 所以如果缓冲被缩小到小于 4 个字节，类型化数组就将超出范围</span></span>
<span class="line"><span style="color:#E1E4E8;">buffer.</span><span style="color:#B392F0;">resize</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(float32.byteLength); </span><span style="color:#6A737D;">// 0</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">buffer</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ArrayBuffer</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">8</span><span style="color:#24292E;">, { maxByteLength: </span><span style="color:#005CC5;">16</span><span style="color:#24292E;"> });</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">float32</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Float32Array</span><span style="color:#24292E;">(buffer, </span><span style="color:#005CC5;">4</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#6A737D;">// float32 是长度跟踪的，但它只从第 4 个字节开始，直到缓冲的结尾，</span></span>
<span class="line"><span style="color:#6A737D;">// 所以如果缓冲被缩小到小于 4 个字节，类型化数组就将超出范围</span></span>
<span class="line"><span style="color:#24292E;">buffer.</span><span style="color:#6F42C1;">resize</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">3</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(float32.byteLength); </span><span style="color:#6A737D;">// 0</span></span></code></pre></div></div><h2 id="静态方法" tabindex="-1">静态方法 <a class="header-anchor" href="#静态方法" aria-label="Permalink to &quot;静态方法&quot;">​</a></h2><h2 id="typedarray-from" tabindex="-1">TypedArray.from() <a class="header-anchor" href="#typedarray-from" aria-label="Permalink to &quot;TypedArray.from()&quot;">​</a></h2><ul><li><strong>描述</strong>： 从一个类数组或者可迭代对象中创建一个新类型数组。这个方法和 Array.from() 类似。</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">TypedArray.</span><span style="color:#B392F0;">from</span><span style="color:#E1E4E8;">(arrayLike, mapFn)</span></span>
<span class="line"><span style="color:#E1E4E8;">TypedArray.</span><span style="color:#B392F0;">from</span><span style="color:#E1E4E8;">(arrayLike, mapFn, thisArg)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">TypedArray.</span><span style="color:#6F42C1;">from</span><span style="color:#24292E;">(arrayLike, mapFn)</span></span>
<span class="line"><span style="color:#24292E;">TypedArray.</span><span style="color:#6F42C1;">from</span><span style="color:#24292E;">(arrayLike, mapFn, thisArg)</span></span></code></pre></div><p>该处<code>TypedArray</code>指代它的所有子类。</p><ul><li><strong>参数</strong>： <ul><li><code>arrayLike</code>：想要转换为类型数组的类数组或者可迭代对象。</li><li><code>mapFn[可选]</code>：如果指定了该参数，则最后生成的类型数组会经过该函数的加工处理后再返回。</li><li><code>thisArg[可选]</code>：执行 mapFn 函数时 this 的值。</li></ul></li><li><strong>返回</strong>：一个新的 TypedArray 实例。</li></ul><details class="details custom-block"><summary>Array.from() 和 TypedArray.from() 之间有一些微妙的区别：</summary><ul><li>如果 |this| 的值传递给 TypedArray.from 不是一个构造器，TypedArray.from 将抛出{jsxref(&quot;TypeError&quot;)}}, 而 Array.from 默认将创建一个 Array.</li><li>TypedArray.from 使用[Put] 而 rray.from 使用[DefineProperty]]. 因此，当和 Proxy 对象一起时，它调用 handler.set 创建一个新的元素而非 handler.defineProperty.</li><li>当 from 获得一个迭代器时，TypedArray 一开始收集迭代器中的所有值，此时创建一个 |this| 的实例用于计数，然后在实例中设置值。 Array.from 设置每个从迭代器其中获取的值，最后设置它的长度。</li><li>当 Array.from 获得一个不可迭代的类数组时，it respects holes, 而 TypedArray.from 将确保结果是 dense</li></ul></details><h2 id="typedarray-of" tabindex="-1">TypedArray.of() <a class="header-anchor" href="#typedarray-of" aria-label="Permalink to &quot;TypedArray.of()&quot;">​</a></h2><ul><li><strong>描述</strong>：创建一个具有可变数量参数的新类型数组。此方法几乎与 Array.of() 相同。</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">TypedArray.</span><span style="color:#B392F0;">of</span><span style="color:#E1E4E8;">(element0)</span></span>
<span class="line"><span style="color:#E1E4E8;">TypedArray.</span><span style="color:#B392F0;">of</span><span style="color:#E1E4E8;">(element0, element1)</span></span>
<span class="line"><span style="color:#E1E4E8;">TypedArray.</span><span style="color:#B392F0;">of</span><span style="color:#E1E4E8;">(element0, element1, </span><span style="color:#6A737D;">/* ... ,*/</span><span style="color:#E1E4E8;"> elementN)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">TypedArray.</span><span style="color:#6F42C1;">of</span><span style="color:#24292E;">(element0)</span></span>
<span class="line"><span style="color:#24292E;">TypedArray.</span><span style="color:#6F42C1;">of</span><span style="color:#24292E;">(element0, element1)</span></span>
<span class="line"><span style="color:#24292E;">TypedArray.</span><span style="color:#6F42C1;">of</span><span style="color:#24292E;">(element0, element1, </span><span style="color:#6A737D;">/* ... ,*/</span><span style="color:#24292E;"> elementN)</span></span></code></pre></div><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">Uint8Array.</span><span style="color:#B392F0;">of</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// Uint8Array [ 1 ]</span></span>
<span class="line"><span style="color:#E1E4E8;">Int8Array.</span><span style="color:#B392F0;">of</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;1&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&quot;2&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&quot;3&quot;</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// Int8Array [ 1, 2, 3 ]</span></span>
<span class="line"><span style="color:#E1E4E8;">Float32Array.</span><span style="color:#B392F0;">of</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// Float32Array [ 1, 2, 3 ]</span></span>
<span class="line"><span style="color:#E1E4E8;">Int16Array.</span><span style="color:#B392F0;">of</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">undefined</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// IntArray [ 0 ]</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">Uint8Array.</span><span style="color:#6F42C1;">of</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">); </span><span style="color:#6A737D;">// Uint8Array [ 1 ]</span></span>
<span class="line"><span style="color:#24292E;">Int8Array.</span><span style="color:#6F42C1;">of</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;1&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;2&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;3&quot;</span><span style="color:#24292E;">); </span><span style="color:#6A737D;">// Int8Array [ 1, 2, 3 ]</span></span>
<span class="line"><span style="color:#24292E;">Float32Array.</span><span style="color:#6F42C1;">of</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">); </span><span style="color:#6A737D;">// Float32Array [ 1, 2, 3 ]</span></span>
<span class="line"><span style="color:#24292E;">Int16Array.</span><span style="color:#6F42C1;">of</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">undefined</span><span style="color:#24292E;">); </span><span style="color:#6A737D;">// IntArray [ 0 ]</span></span></code></pre></div><h2 id="实例属性" tabindex="-1">实例属性 <a class="header-anchor" href="#实例属性" aria-label="Permalink to &quot;实例属性&quot;">​</a></h2><h2 id="typedarray-prototype-buffer" tabindex="-1">TypedArray.prototype.buffer <a class="header-anchor" href="#typedarray-prototype-buffer" aria-label="Permalink to &quot;TypedArray.prototype.buffer&quot;">​</a></h2><ul><li><strong>描述</strong>：表示由 TypedArray 在构造期间引用的 ArrayBuffer。</li></ul><h2 id="typedarray-prototype-bytelength" tabindex="-1">TypedArray.prototype.byteLength <a class="header-anchor" href="#typedarray-prototype-bytelength" aria-label="Permalink to &quot;TypedArray.prototype.byteLength&quot;">​</a></h2><ul><li><strong>描述</strong>：返回该类型化数组的长度（字节数）。</li></ul><h2 id="typedarray-prototype-byteoffset" tabindex="-1">TypedArray.prototype.byteOffset <a class="header-anchor" href="#typedarray-prototype-byteoffset" aria-label="Permalink to &quot;TypedArray.prototype.byteOffset&quot;">​</a></h2><ul><li><strong>描述</strong>：返回该类型化数组距离其ArrayBuffer起始位置的偏移（字节数）</li></ul><h2 id="typedarray-prototype-length" tabindex="-1">TypedArray.prototype.length <a class="header-anchor" href="#typedarray-prototype-length" aria-label="Permalink to &quot;TypedArray.prototype.length&quot;">​</a></h2><ul><li><strong>描述</strong>：返回该类型化数组的长度（以元素为单位）。</li></ul><h2 id="实例方法" tabindex="-1">实例方法 <a class="header-anchor" href="#实例方法" aria-label="Permalink to &quot;实例方法&quot;">​</a></h2><h2 id="typedarray-prototype-数组的大部分方法" tabindex="-1">TypedArray.prototype.数组的大部分方法 <a class="header-anchor" href="#typedarray-prototype-数组的大部分方法" aria-label="Permalink to &quot;TypedArray.prototype.数组的大部分方法&quot;">​</a></h2>`,26);function g(A,F,h,u,b,C){const l=p("lines");return t(),r("div",null,[y,s("p",null,[a("TypedArray 对象描述了底层"),E,a("。没有称为 TypedArray 的全局属性，也没有直接可用的 TypedArray 构造函数。"),n(l,{text:"是所有 TypedArray 子类的通用父类"}),a("。它只能通过子类对象原型链访问到，如：Object.getPrototypeOf(Int8Array)。")]),d,n(l,{text:"所有的`类型化数组`都是基于 ArrayBuffer 进行操作的，可以借此观察到每个元素的确切字节表示。因此二进制格式中的数字编码方式具有重要意义。"}),i,s("p",null,[a("Int8Array、Unit8Array 和 Uint8ClampedArray 以外的其他类型数组都将每个元素存储为多个字节。这些字节可以按照从最高有效位到最低有效位（大端序）或从最低有效位到最高有效位（小端序）的顺序进行排序。类型化数组始终使用平台的本机字节顺序。"),n(l,{text:"如果要在缓冲区中写入和读取时指定字节顺序，应该使用 DataView"}),a("。")]),s("p",null,[a("当向这些类型化数组写入时，"),n(l,{text:"超出可表示范围的值将被标准化"}),a("。")]),f])}const m=e(c,[["render",g]]);export{x as __pageData,m as default};
